<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于Opencv的学习</title>
    <link href="/2025/04/27/%E5%88%9D%E5%AD%A6OpenCV/"/>
    <url>/2025/04/27/%E5%88%9D%E5%AD%A6OpenCV/</url>
    
    <content type="html"><![CDATA[<h4 id="关于Opencv的学习"><a href="#关于Opencv的学习" class="headerlink" title="关于Opencv的学习"></a>关于Opencv的学习</h4><blockquote><p>前言</p></blockquote><p>&emsp;&emsp;因为学校要参与一个机器人比赛，需要完成让机器人分辨颜色并且对其进行跟踪并抓取，因还是第一次参赛，具体是什么物品还不是很清楚，而且自身的Opencv还没有学完并且停滞了，但是这一次又是给了一次机会让自己去学习OpenCV的理由了。</p><blockquote><p>目录</p></blockquote><ol><li>图片的显示</li><li>图片的读取</li><li>区域裁剪</li><li>绘制图形和文字</li><li>均值滤波</li><li>特征提取</li><li>模板匹配</li><li>梯度算法</li><li>阈值算法</li><li>形态学操作</li><li>摄像头的读取</li></ol><blockquote><p>代码</p></blockquote><ol><li>图片的显示</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取图片</span><br>    image = cv2.imread(<span class="hljs-string">&#x27;opencv_logo.jpg&#x27;</span>)<br>    <span class="hljs-comment"># 输出一下image对象</span><br>    <span class="hljs-comment"># image.shape存储的是一个元组，分别对应图片的 高度(垂直)，宽度(水平)，通道数(灰度图形没有通道数)</span><br>    <span class="hljs-built_in">print</span>(image.shape)<br>    <span class="hljs-comment"># 显示图片 第一个参数是显示的标题(注意：中文会乱码！) 第二个参数的图片的对象</span><br>    cv2.imshow(<span class="hljs-string">&#x27;title&#x27;</span>, image)<br>    <span class="hljs-comment"># 因为im_show是非堵塞的，所以我们要阻止python程序结束</span><br>    cv2.waitKey(<span class="hljs-number">0</span>)  <span class="hljs-comment">#0是一直等待按键的反馈，如果没有按键按下就是返回-1</span><br>    <span class="hljs-comment"># 关闭窗口</span><br>    cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p>运行结果:<br><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/1.%E5%9B%BE%E7%89%87%E7%9A%84%E6%98%BE%E7%A4%BA.webp" alt="1.图片的显示"></p><ol start="2"><li>RGB彩色通道</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取图片</span><br>    image = cv2.imread(<span class="hljs-string">&#x27;opencv_logo.jpg&#x27;</span>)<br>    <span class="hljs-comment"># BGR是opencv默认的颜色通道顺序，因为读取的是彩色图片，所以拥有3个通道，分别对应BGR的各个灰度图</span><br>    <span class="hljs-comment"># 分别获取对应的通道并且显示，可以采用分片的方式去进行获取</span><br>    bImage = image[:, :, <span class="hljs-number">0</span>]<br>    gImage = image[:, :, <span class="hljs-number">1</span>]<br>    rImage = image[:, :, <span class="hljs-number">2</span>]<br>    <span class="hljs-comment"># 显示图片</span><br>    cv2.imshow(<span class="hljs-string">&#x27;bImage&#x27;</span>, bImage)<br>    cv2.imshow(<span class="hljs-string">&#x27;gImage&#x27;</span>, gImage)<br>    cv2.imshow(<span class="hljs-string">&#x27;rImage&#x27;</span>, rImage)<br><br>    <span class="hljs-comment"># 等待键盘的输入</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;q&#x27;</span>:<br>        <span class="hljs-comment"># 释放窗口</span><br>        cv2.destroyAllWindows()<br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/2.RGB%E5%BD%A9%E8%89%B2%E9%80%9A%E9%81%93.webp" alt="RGB彩色通道"></p><p>知识点:</p><ul><li>灰度图片没有通道</li><li>彩色图片有3个通道，分别对应BGR的各个灰度图，使用分片的方式获取通道 [::0] B [::1] G[::2] R </li><li>每个通道图对应的相应颜色的灰度图</li></ul><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/2.RGB%E5%BD%A9%E8%89%B2%E9%80%9A%E9%81%931.webp" alt="RGB彩色通道"></p><ol start="3"><li>区域裁剪</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取图形</span><br>    image = cv2.imread(<span class="hljs-string">&#x27;opencv_logo.jpg&#x27;</span>)<br>    <span class="hljs-comment"># 获取图像的宽高</span><br>    height, width = image.shape[:<span class="hljs-number">2</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;图像的宽高：&#x27;</span>, width, height)<br>    <span class="hljs-comment"># 定义裁剪区域 先y轴 再x轴,例如文字部分使用画图确定的矩形部分为左上角为(29,170)，右下角为(215,225)，</span><br>    <span class="hljs-comment"># 那么y轴从左上角为170到右下角225，x轴为左上角29到右下角215</span><br>    roi = image[<span class="hljs-number">170</span>:<span class="hljs-number">225</span>,<span class="hljs-number">29</span>:<span class="hljs-number">215</span>]<br>    <span class="hljs-comment"># 显示原图</span><br>    cv2.imshow(<span class="hljs-string">&#x27;Original&#x27;</span>, image)<br>    <span class="hljs-comment"># 显示裁剪后的图像</span><br>    cv2.imshow(<span class="hljs-string">&#x27;Roi&#x27;</span>, roi)<br>    <span class="hljs-comment"># 等待用户按键</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;q&#x27;</span>:<br>        cv2.destroyAllWindows()<br>    <span class="hljs-comment"># 结束程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/3.%E5%8C%BA%E5%9F%9F%E8%A3%81%E5%89%AA.webp" alt="3.区域裁剪"></p><p>知识点:</p><ul><li>裁剪区域是先y轴再x轴</li><li>如果需要具体裁剪出某一个部分，推荐使用画图工具确定裁剪的像素点的位置，<br>例如：<br><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/3.%E5%8C%BA%E5%9F%9F%E8%A3%81%E5%89%AA1.webp" alt="3.区域裁剪"><br><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/3.%E5%8C%BA%E5%9F%9F%E8%A3%81%E5%89%AA2.webp" alt="3.区域裁剪"><br><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/3.%E5%8C%BA%E5%9F%9F%E8%A3%81%E5%89%AA3.webp" alt="3.区域裁剪"><br>这样子就可以准确而又清楚的裁剪出想要的部分。</li></ul><ol start="4"><li>绘制图形和文字</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment">#用于创建数组</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建一个空白图像(0是全黑 , 255是全白)</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    返回来一个给定形状和类型的用0填充的数组;</span><br><span class="hljs-string">    原型： numpy.zeros(shape, dtype=float, order=‘C’)</span><br><span class="hljs-string">    shape:形状，使用元组(高,宽,通道数)</span><br><span class="hljs-string">    dtype:数据类型，可选参数，默认numpy.float64</span><br><span class="hljs-string">    order:可选参数，c代表与c语言类似，行优先；F代表列优先</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    blackImage = np.zeros((<span class="hljs-number">512</span>,<span class="hljs-number">512</span>,<span class="hljs-number">3</span>),dtype=np.uint8)<br>    <span class="hljs-comment"># whiteImage = np.ones((512,512,3),dtype=np.uint8) * 255  #全白图像,函数于zeros一致,但是因为是全部白色,所以需要*255,如果不*，那么还是黑色</span><br>    <span class="hljs-comment"># 同理,这样也可以创建出一个其它纯色的图像</span><br>    <span class="hljs-comment"># 创建一个红色的图像，例如 redImage = np.ones((512,512,3),dtype=np.uint8) * [0,0,255]</span><br>    <span class="hljs-comment">#cv2.imshow(&#x27;white&#x27;,whiteImage)</span><br><br>    <span class="hljs-comment"># 画一个矩形  参数依次为:图像,左上角坐标,右下角坐标,颜色,线宽</span><br>    cv2.rectangle(blackImage,(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>),(<span class="hljs-number">200</span>,<span class="hljs-number">200</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 画一条线  参数依次为:图像,起点坐标,终点坐标,颜色,线宽</span><br>    cv2.line(blackImage,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">511</span>,<span class="hljs-number">511</span>),(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 画一个圆  参数依次为:图像,圆心坐标,半径,颜色,线宽</span><br>    cv2.circle(blackImage,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<span class="hljs-number">100</span>,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 画一个椭圆  参数依次为:图像,中心坐标,轴长度,旋转角度,起始角度,结束角度,颜色,线宽</span><br>    <span class="hljs-comment">#这个图像会让椭圆向上倾斜30°，是因为旋转角度为30，如果结束角度不是360，而是180，那么就只会画一半</span><br>    cv2.ellipse(blackImage,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>), (<span class="hljs-number">100</span>,<span class="hljs-number">50</span>) ,<span class="hljs-number">0</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">360</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 画一个多边形  参数依次为:图像,顶点坐标,是否闭合,颜色,线宽</span><br>    <span class="hljs-comment">#注意:顶点坐标需要使用np.array()转换成数组</span><br>    pts = np.array([[<span class="hljs-number">10</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">30</span>],[<span class="hljs-number">70</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">50</span>,<span class="hljs-number">10</span>]],np.int32)<br>    pts = pts.reshape((-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) <span class="hljs-comment">#将数组转换成二维数组</span><br>    cv2.polylines(blackImage,[pts],<span class="hljs-literal">True</span>,(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment"># 在图像上写文字  参数依次为:图像,文字内容,文字位置,字体,字体大小,颜色,线宽</span><br>    cv2.putText(blackImage,<span class="hljs-string">&#x27;Hello World&#x27;</span>,(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>),cv2.FONT_HERSHEY_SIMPLEX,<span class="hljs-number">1</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment">#先画好,再显示</span><br>    cv2.imshow(<span class="hljs-string">&#x27;black&#x27;</span>,blackImage)<br>    cv2.waitKey(<span class="hljs-number">0</span>)<br>    cv2.destroyAllWindows()<br>````<br><br>运行结果<br>![<span class="hljs-number">4.</span>绘制图形和文字](/img/docs/初学OpenCV/<span class="hljs-number">4.</span>绘制图形和文字.webp)<br><br>知识点:<br><br>- 画圆的半径是相对于圆心而言的，所以半径为<span class="hljs-number">100</span>，圆心为(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>)，那么圆心到圆周的距离就是<span class="hljs-number">100</span><br>- 画椭圆的旋转角度是相对于x轴而言的，所以旋转角度为<span class="hljs-number">30</span>°，那么椭圆就会向上倾斜<span class="hljs-number">30</span>°<br>- 椭圆的轴长度是圆心为起点,(x,y)轴的长度，如果轴长度为(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>)，则就是一个水平扁的椭圆，如果x,y一样，那就是个圆形状。<br>- 画多边形需要将顶点坐标转换成二维数组，并且使用reshape函数进行转换<br><br><span class="hljs-number">5.</span> 均值滤波<br><br>```python<br><span class="hljs-keyword">import</span> cv2<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取一个拥有噪点的图片</span><br>    image = cv2.imread(<span class="hljs-string">&#x27;plane.jpg&#x27;</span>)<br>    <span class="hljs-comment">#显示图片</span><br>    cv2.imshow(<span class="hljs-string">&#x27;Original&#x27;</span>,image)<br><br>    <span class="hljs-comment"># 使用高斯滤波  参数依次为:图像,高斯核大小(元组),标准差</span><br>    gaussianImage = cv2.GaussianBlur(image,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">#显示图片</span><br>    cv2.imshow(<span class="hljs-string">&#x27;Gaussian&#x27;</span>,gaussianImage)<br><br>    <span class="hljs-comment"># 使用中值滤波器 参数依次为:图像,滤波器大小</span><br>    medianImage = cv2.medianBlur(image,<span class="hljs-number">5</span>)<br>    <span class="hljs-comment">#显示图片</span><br>    cv2.imshow(<span class="hljs-string">&#x27;Median&#x27;</span>,medianImage)<br><br>    <span class="hljs-comment"># 均值滤波</span><br>    meanImage = cv2.blur(image,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br>    <span class="hljs-comment">#显示图片</span><br>    cv2.imshow(<span class="hljs-string">&#x27;Mean&#x27;</span>,meanImage)<br><br><br>    <span class="hljs-comment"># 等待按钮按下</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;q&#x27;</span>:<br>        cv2.destroyAllWindows()<br><br>    <span class="hljs-comment">#结束程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/5.%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2.webp" alt="5.均值滤波"></p><p>知识点:</p><blockquote><p>之前的太简单了,现在要认真开始学习了，(<del>这里还是暂时不了解各个滤波器的原理，直接哪个图形上哪个滤波器！</del>),算了，开摆</p></blockquote><ol><li>图像噪音：<a href="https://blog.csdn.net/qq_28258885/article/details/112664028">https://blog.csdn.net/qq_28258885/article/details/112664028</a></li><li>图像数据增强的方法:<a href="https://zhuanlan.zhihu.com/p/580222454">https://zhuanlan.zhihu.com/p/580222454</a></li><li>OpenCV（十一）图像滤波(平滑处理)（平均、中值、高斯、双边滤波）:<a href="https://blog.csdn.net/great_yzl/article/details/119645423">https://blog.csdn.net/great_yzl/article/details/119645423</a></li><li>OpenCV入门7——OpenCV中的滤波器（包括低通滤波与高通滤波，其中低通滤波用于降噪，而高通滤波用于边缘检测）：<a href="https://blog.csdn.net/qq_44631615/article/details/134445747">https://blog.csdn.net/qq_44631615/article/details/134445747</a></li></ol><blockquote><p>这里有个小坑，就是高斯滤波的核大小必须是奇数，例如(5,5)，(3,3)等等，因为奇数才能确定一个中心点，而偶数的话，就没有中心点，无法确定滤波的核大小(AI生成,NB!)</p></blockquote><blockquote><p>线性滤波</p></blockquote><ol><li>均值滤波（Mean Filter）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 均值滤波 参数依次为:图像,滤波器大小</span><br>meanImage = cv2.blur(image,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;适用于用来椒盐（脉冲）噪声和高斯噪声进行滤波。</p><p>&emsp;&emsp;【算法简单，计算速度快，但会造成图像一定程度上的模糊。】</p><p>&emsp;&emsp;【均值滤波器（邻域平均法）的平滑效果与所采用领域的半径（模板大小）有关。半径越大，则图像的模糊程度越大。】</p><ol start="2"><li>方框滤波（Box Filtering）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方框滤波 参数依次为:图像,滤波器大小,是否归一化</span><br>boxImage = cv2.boxFilter(image,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;方框滤波与均值滤波类似，也是对邻域内的像素进行平均，但它有可选择的归一化操作。如果选择归一化，那么方框滤波就是均值滤波；如果不选择归一化，那么方框滤波可以放大图像中的噪声。</p><ol start="3"><li>高斯滤波（Gaussian Filter）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 高斯滤波 参数依次为:图像,高斯核大小(元组),标准差</span><br>gaussianImage = cv2.GaussianBlur(image,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>&emsp;&emsp; 适用于消除高斯噪声，广泛应用于图像处理的减噪过程。</p><p>&emsp;&emsp;【高斯滤波器是一种线性平滑滤波器，适用于消除高斯噪声，对图像进行平滑处理。】</p><blockquote><p>非线性滤波</p></blockquote><ol><li>中值滤波（Median Filter）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 中值滤波 参数依次为:图像,滤波器大小</span><br>medianImage = cv2.medianBlur(image,<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;对于椒盐噪声,中值滤波效果比均值滤波效果好；</p><p>&emsp;&emsp;对于高斯噪声，均值滤波效果比中值滤波效果好。</p><p>2.双边滤波（Bilateral Filtering）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 双边滤波 参数依次为:图像,滤波器大小,空间高斯函数标准差,灰度值相似性高斯函数标准差</span><br>bilateralfilter = cv2.bilateralFilter(img,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;当需要边缘信息的时候可以使用双边滤波</p><p>&emsp;&emsp;【使用高斯滤波会较明显地模糊边缘，对于高频细节的保护效果并不明显。而双边滤波综合考虑到空间信息和色彩信息，在滤波过程中能够有效的地保护图像内部的边缘信息。】</p><ol start="6"><li>特征提取</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取图像</span><br>    image = cv2.imread(<span class="hljs-string">&#x27;opencv_logo.jpg&#x27;</span>)<br>    <span class="hljs-comment"># 转换为灰度图像 :cvtColor能够转换很多种图像</span><br>    gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<br>    <span class="hljs-comment"># 获取图像的特征点 参数:图像,特征点数量,特征点质量,特征点距离</span><br>    corners:cv2.typing.MatLike = cv2.goodFeaturesToTrack(gray, <span class="hljs-number">25</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># 遍历特征点</span><br>    <span class="hljs-keyword">for</span> corner <span class="hljs-keyword">in</span> corners:<br>        <span class="hljs-comment"># 获取特征点的坐标</span><br>        x, y = corner.ravel() <span class="hljs-comment">#注意，此处没有补全</span><br>        <span class="hljs-comment"># 在图像上绘制特征点</span><br>        cv2.circle(image, (<span class="hljs-built_in">int</span>(x),<span class="hljs-built_in">int</span>(y)), <span class="hljs-number">3</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 显示图像</span><br>    cv2.imshow(<span class="hljs-string">&#x27;corners&#x27;</span>, image)<br>    <span class="hljs-comment"># 等待按键</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        cv2.destroyAllWindows()<br>    <span class="hljs-comment"># 退出程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/6.%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96.webp" alt="6.特征提取.png"></p><ol start="7"><li>模板匹配</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取图像</span><br>    image = cv2.imread(<span class="hljs-string">&#x27;poker.jpg&#x27;</span>)<br>    <span class="hljs-comment"># 转换为灰度图像</span><br>    gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<br><br>    <span class="hljs-comment"># 创建图像模板，及感兴趣区域</span><br>    roi = gray[<span class="hljs-number">69</span>:<span class="hljs-number">109</span>:,<span class="hljs-number">230</span>:<span class="hljs-number">267</span>]<br><br>    <span class="hljs-comment">#显示模板</span><br>    cv2.imshow(<span class="hljs-string">&#x27;roi&#x27;</span>, roi)<br><br>    <span class="hljs-comment"># 进行模板匹配</span><br>    <span class="hljs-keyword">match</span> = cv2.matchTemplate(gray,roi,cv2.TM_CCOEFF_NORMED)<br>    <span class="hljs-comment"># 设定阈值</span><br>    threshold = <span class="hljs-number">0.8</span><br>    <span class="hljs-comment"># 找到匹配的位置，，它是一个元组，包含两个数组，分别对应满足条件（即匹配值大于等于阈值）的元素的行索引和列索引。</span><br>    loc = np.where(<span class="hljs-keyword">match</span> &gt;= threshold)<br>    <span class="hljs-comment"># 打印匹配的位置</span><br>    <span class="hljs-built_in">print</span>(loc)<br>    <span class="hljs-comment">#loc[::-1]：这是对 loc 元组进行反转操作。[::-1] 是 Python 里的切片语法，用于反转序列。反转后，原本的列索引数组在前，行索引数组在后。</span><br>    <span class="hljs-comment">#*loc[::-1]：* 是解包操作符，它把 loc[::-1] 这个元组里的数组解包成独立的参数传递给 zip 函数。</span><br>    <span class="hljs-comment">#zip 函数用于将多个可迭代对象中对应位置的元素组合成元组，返回一个迭代器。这里 zip 把解包后的列索引数组和行索引数组中对应位置的元素组合成 (列索引, 行索引) 形式的元组。</span><br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    在 OpenCV 里，cv2.rectangle 函数需要矩形左上角的坐标作为参数。通过 np.where 得到的行索引和列索引是分开存储的，借助 zip 函数能把它们组合成 (x, y) 形式的坐标对，这样就能方便地在图像上绘制矩形框。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># # 遍历匹配的位置</span><br>    <span class="hljs-comment"># for pt in zip(*loc[::-1]):</span><br>    <span class="hljs-comment">#     # 绘制矩形框,  (pt[0] + 37, pt[1] + 40)是指的矩形框的右下角的坐标，通过加37和40来调整矩形框的大小，以适应模板的大小。</span><br>    <span class="hljs-comment">#     cv2.rectangle(image, pt, (pt[0] + 37, pt[1] + 40), (0, 0, 255), 2)</span><br>    <span class="hljs-comment"># 或者</span><br>    w,h = roi.shape[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*loc[::-<span class="hljs-number">1</span>]):<br>        x1,y1 = pt[<span class="hljs-number">0</span>],pt[<span class="hljs-number">1</span>]<br>        x2,y2 = pt[<span class="hljs-number">0</span>] + w,pt[<span class="hljs-number">1</span>] + h<br>        cv2.rectangle(image, (x1,y1),(x2,y2), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 显示图像</span><br>    cv2.imshow(<span class="hljs-string">&#x27;image&#x27;</span>, image)<br><br>    <span class="hljs-comment"># 等待按键</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        cv2.destroyAllWindows()<br><br>    <span class="hljs-comment"># 退出程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/7.%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D.webp" alt="7.模板匹配"></p><p>知识点:</p><ul><li>模板匹配是一种在图像中查找特定模式的方法。它通常用于在图像中查找特定的物体或特征。模板匹配的基本思想是将一个模板图像与输入图像进行比较，找到与模板图像最相似的位置。</li><li>(loc &#x3D; np.where(match &gt;&#x3D; threshold) )找到匹配的位置，，它是一个元组，包含两个数组，分别对应满足条件（即匹配值大于等于阈值）的元素的行索引和列索引。</li><li>loc[::-1]：这是对 loc 元组进行反转操作。[::-1] 是 Python 里的切片语法，用于反转序列。反转后，原本的列索引数组在前，行索引数组在后。</li></ul><p>其它:<br>    我试过了用梅花，不得不说匹配很拉，<del>不知道是不是我写的问题</del>(应该就是我写的问题，计算机怎么会出错呢)</p><ol start="8"><li>梯度算法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 直接读取灰度图像,使用参数cv2.IMREAD_GRAYSCALE来读取图像</span><br>    gray = cv2.imread(<span class="hljs-string">&#x27;opencv_logo.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)<br><br>    <span class="hljs-comment"># 使用Laplace算子进行边缘检测，cv2.CV_64F是输出图像的深度，通常使用64位浮点数</span><br>    laplacian = cv2.Laplacian(gray,cv2.CV_64F)<br><br>    <span class="hljs-comment"># 将结果转换为8位无符号整数，范围在0-255之间，加了这个就很清楚了</span><br>    laplacian = cv2.convertScaleAbs(laplacian)<br><br>    <span class="hljs-comment"># 使用Canny算子进行边缘检测，第一个参数是输入图像，第二个和第三个参数是阈值，</span><br>    canny = cv2.Canny(gray,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>)<br><br><br>    <span class="hljs-comment"># 显示图像</span><br>    cv2.imshow(<span class="hljs-string">&#x27;gray&#x27;</span>, gray)<br>    cv2.imshow(<span class="hljs-string">&#x27;laplacian&#x27;</span>, laplacian)<br>    cv2.imshow(<span class="hljs-string">&#x27;canny&#x27;</span>, canny)<br><br>    <span class="hljs-comment"># 等待按键</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        cv2.destroyAllWindows()<br><br>    <span class="hljs-comment"># 退出程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/8.%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%95.webp" alt="8.梯度算法"></p><p>知识点:(全部由AI生成)</p><ul><li>梯度算法是一种常用的图像边缘检测方法，它可以用来检测图像中的边缘。</li><li>梯度算法的基本思想是通过计算图像中像素点的梯度来检测边缘。梯度是指像素点的变化率，它可以用来表示图像中像素点的变化程度。</li><li>梯度算法的常用方法有Laplace算子和Sobel算子。</li><li>Laplace算子是一种二阶导数算子，它可以用来计算图像中像素点的梯度。</li><li>Sobel算子是一种一阶导数算子，它可以用来计算图像中像素点的梯度。</li><li>梯度算法的优点是可以检测图像中的边缘，但是它也有一些缺点，例如它不能检测出图像中的角点。</li><li>梯度算法的应用非常广泛，例如在图像分割、目标检测、图像配准等领域都有广泛的应用。</li><li>梯度算法的实现步骤如下：</li><li>读取图像。</li><li>转换为灰度图像。</li><li>使用Laplace算子或Sobel算子进行边缘检测。</li><li>将结果转换为8位无符号整数，范围在0-255之间。</li><li>显示图像。</li><li>等待按键。</li><li>退出程序。</li></ul><p>图像的梯度:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/8.%E6%A2%AF%E5%BA%A6%E7%AE%97%E6%B3%951.webp" alt="8.梯度算法"></p><ol start="9"><li>阈值算法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取图像,直接使用参数cv2.IMREAD_GRAYSCALE来读取灰度图像</span><br>    gray = cv2.imread(<span class="hljs-string">&#x27;bookpage.jpg&#x27;</span>,cv2.IMREAD_GRAYSCALE)<br><br>    <span class="hljs-comment"># 阈值化处理，第一个参数是输入图像，第二个参数是阈值，第三个参数是最大灰度值，</span><br>    ret,binary = cv2.threshold(gray,<span class="hljs-number">10</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY)<br><br>    <span class="hljs-comment"># 使用自适应阈值化处理，第一个参数是输入图像，第二个参数是最大灰度值，第三个参数是自适应方法，第四个参数是阈值类型，第五个参数是块大小，第六个参数是常数C</span><br>    binary_adaptive = cv2.adaptiveThreshold(gray,<span class="hljs-number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,<span class="hljs-number">115</span>,<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 使用OTSU算法进行阈值化处理，第一个参数是输入图像，第二个参数是最大灰度值，第三个参数是阈值类型，第四个参数是阈值类型，第五个参数是阈值</span><br>    ret_otsu,otsu = cv2.threshold(gray,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OTSU threshold:&#x27;</span>,ret_otsu)<br><br>    <span class="hljs-comment"># 显示图像</span><br>    cv2.imshow(<span class="hljs-string">&#x27;gray&#x27;</span>, gray)<br>    cv2.imshow(<span class="hljs-string">&#x27;binary&#x27;</span>, binary)<br>    cv2.imshow(<span class="hljs-string">&#x27;binary_adaptive&#x27;</span>, binary_adaptive)<br>    cv2.imshow(<span class="hljs-string">&#x27;otsu&#x27;</span>, otsu)<br><br>    <span class="hljs-comment"># 等待按键</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        cv2.destroyAllWindows()<br><br>    <span class="hljs-comment"># 退出程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/9.%E9%98%88%E5%80%BC%E7%AE%97%E6%B3%95.webp" alt="9.阈值算法"></p><ol start="10"><li>形态学操作</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 读取图像,直接使用参数cv2.IMREAD_GRAYSCALE来读取灰度图像</span><br>    gray = cv2.imread(<span class="hljs-string">&#x27;bookpage.jpg&#x27;</span>,cv2.IMREAD_GRAYSCALE)<br><br>    <span class="hljs-comment"># 阈值化处理，第一个参数是输入图像，第二个参数是阈值，第三个参数是最大灰度值，</span><br>    ret,binary = cv2.threshold(gray,<span class="hljs-number">10</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY)<br><br>    <span class="hljs-comment"># 使用自适应阈值化处理，第一个参数是输入图像，第二个参数是最大灰度值，第三个参数是自适应方法，第四个参数是阈值类型，第五个参数是块大小，第六个参数是常数C</span><br>    binary_adaptive = cv2.adaptiveThreshold(gray,<span class="hljs-number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,<span class="hljs-number">115</span>,<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># 使用OTSU算法进行阈值化处理，第一个参数是输入图像，第二个参数是最大灰度值，第三个参数是阈值类型，第四个参数是阈值类型，第五个参数是阈值</span><br>    ret_otsu,otsu = cv2.threshold(gray,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;OTSU threshold:&#x27;</span>,ret_otsu)<br><br>    <span class="hljs-comment"># 显示图像</span><br>    cv2.imshow(<span class="hljs-string">&#x27;gray&#x27;</span>, gray)<br>    cv2.imshow(<span class="hljs-string">&#x27;binary&#x27;</span>, binary)<br>    cv2.imshow(<span class="hljs-string">&#x27;binary_adaptive&#x27;</span>, binary_adaptive)<br>    cv2.imshow(<span class="hljs-string">&#x27;otsu&#x27;</span>, otsu)<br><br>    <span class="hljs-comment"># 等待按键</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>        cv2.destroyAllWindows()<br><br>    <span class="hljs-comment"># 退出程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运算结果:</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/10.%E5%BD%A2%E6%80%81%E5%AD%A6%E6%93%8D%E4%BD%9C.webp" alt="10.形态学操作"></p><p>知识点：(AI生成)</p><ul><li>形态学操作是一种基于形状的图像处理方法，它可以用来进行图像的膨胀、腐蚀、开运算、闭运算等操作。</li><li>形态学操作的基本思想是通过对图像中的像素点进行操作来改变图像的形状。</li><li>形态学操作的常用方法有膨胀、腐蚀、开运算、闭运算等。</li><li>膨胀是一种将图像中的白色区域扩大的操作，它可以用来填补图像中的空洞、连接图像中的断开部分等。</li><li>腐蚀是一种将图像中的白色区域缩小的操作，它可以用来去除图像中的噪声、断开图像中的连接部分等。</li><li>开运算是一种先腐蚀后膨胀的操作，它可以用来去除图像中的噪声、断开图像中的连接部分等。</li><li>闭运算是一种先膨胀后腐蚀的操作，它可以用来填补图像中的空洞、连接图像中的断开部分等。</li><li>形态学操作的优点是可以改变图像的形状，但是它也有一些缺点，例如它不能改变图像的颜色。</li><li>形态学操作的应用非常广泛，例如在图像分割、目标检测、图像配准等领域都有广泛的应用。</li><li>形态学操作的实现步骤如下：</li><li>读取图像。</li><li>转换为灰度图像。</li><li>使用阈值化处理。</li><li>使用形态学操作进行处理。</li><li>显示图像。</li><li>等待按键。</li><li>退出程序。</li></ul><ol start="11"><li>摄像头的使用</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 打开摄像头，参数0表示默认摄像头</span><br>    cap = cv2.VideoCapture(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># 检查摄像头是否成功打开</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cap.isOpened():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;摄像头打开失败&#x27;</span>)<br>        exit(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># 循环读取摄像头数据</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 读取摄像头数据</span><br>        ret,frame = cap.read()<br>        <span class="hljs-comment"># 检查是否成功读取</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;读取摄像头数据失败&#x27;</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 显示摄像头数据</span><br>        cv2.imshow(<span class="hljs-string">&#x27;frame&#x27;</span>,frame)<br>        <span class="hljs-comment"># 等待按键</span><br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment"># 释放摄像头</span><br>    cap.release()<br>    <span class="hljs-comment"># 关闭所有窗口</span><br>    cv2.destroyAllWindows()<br>    <span class="hljs-comment"># 退出程序</span><br>    exit(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>运行结果: 这里就不放帅照了，哈哈。</p><blockquote><p>后话</p></blockquote><p>&emsp;&emsp;<del>苦海无涯，学无止境，我要继续学习。</del></p><p>&emsp;&emsp;对于学习我只想用两个表情包来表示：</p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/11.%E4%B8%8D%E4%BB%85%E5%AD%A6%E4%B8%8D%E5%AE%8C%EF%BC%8C%E8%BF%98%E5%AD%A6%E4%B8%8D%E8%BF%9B.webp" alt="11.不仅学不完,还学不进"></p><p><img src="/img/docs/%E5%88%9D%E5%AD%A6OpenCV/12.%E5%AD%A6%E4%B8%8D%E5%AE%8C%E4%BA%86%E5%95%8A%5B%E5%93%AD%E6%AD%BB%5D.webp" alt="12.我这不叫爱学习，只是学不完了啊"></p>]]></content>
    
    
    <categories>
      
      <category>Opencv</category>
      
      <category>计算机视觉</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉 Opencv Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP读取空气质量、光照、控制继电器</title>
    <link href="/2025/04/19/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/"/>
    <url>/2025/04/19/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="物联网系列之ESP主控读取空气、光照等传感器、控制继电器"><a href="#物联网系列之ESP主控读取空气、光照等传感器、控制继电器" class="headerlink" title="物联网系列之ESP主控读取空气、光照等传感器、控制继电器"></a>物联网系列之ESP主控读取空气、光照等传感器、控制继电器</h2><p>相关资料网站:</p><p>esp32c3 SuperMini:<a href="https://www.nologo.tech/product/esp32/esp32c3/esp32c3supermini/esp32C3SuperMini.html">ESP32C3SuperMini 入门</a></p><p>esp8266-01s:<a href="http://www.taichi-maker.com/homepage/iot-development/iot-dev-reference/esp8266-iot-dev-ref/">ESP8266物联网开发参考资料 – 太极创客</a></p><blockquote><h5 id="ESP8266-01S联动继电器与-Home-Assistant"><a href="#ESP8266-01S联动继电器与-Home-Assistant" class="headerlink" title="ESP8266-01S联动继电器与 Home Assistant"></a>ESP8266-01S联动继电器与 Home Assistant</h5></blockquote><p>实物如下：</p><p>ESP8266-01S:</p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/1.webp"></p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/2.webp"></p><p>与ESP8266-01S配套的继电器模块：(默认使用GPIO 0进行触发)</p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/3.webp" alt="ESP01SRealy"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ESP8266WiFi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;DNSServer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ESP8266WebServer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WiFiManager.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;PubSubClient.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;ArduinoJson.h&gt;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RELAY_PIN 0</span><br><span class="hljs-comment">// 建立WiFiManager对象</span><br>WiFiManager wifiManager;<br>WiFiClient espClient;<br>PubSubClient mqttClient;<br><br><span class="hljs-type">bool</span> relay_state = <span class="hljs-literal">false</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqtt_broker_addr = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> mqtt_broker_port = <span class="hljs-number">1883</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqtt_username = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqtt_password = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> mqtt_client_buff_size = <span class="hljs-number">4096</span>;                          <span class="hljs-comment">// 客户端缓存大小（非必须）</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqtt_ha_config_topic = <span class="hljs-string">&quot;HomeAssistant/switch/NightLight/config&quot;</span>;  <span class="hljs-comment">//小夜灯继电器配置</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqtt_ha_state_topic = <span class="hljs-string">&quot;HomeAssistant/switch/NightLight/state&quot;</span>;    <span class="hljs-comment">//小夜灯状态配置</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqtt_ha_command_topic = <span class="hljs-string">&quot;HomeAssistant/switch/NightLight/set&quot;</span>;    <span class="hljs-comment">//小夜灯设置配置</span><br><span class="hljs-type">char</span> mqtt_client_id[<span class="hljs-number">38</span>] = <span class="hljs-string">&quot;ORANGEPI_RELAY_CONTROLLER&quot;</span>;  <span class="hljs-comment">//客户端ID</span><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> previousConnectMillis = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 毫秒时间记录</span><br><span class="hljs-type">const</span> <span class="hljs-type">long</span> intervalConnectMillis = <span class="hljs-number">5000</span>;  <span class="hljs-comment">// 时间间隔</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> previousPublishMillis = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 毫秒时间记录</span><br><span class="hljs-type">const</span> <span class="hljs-type">long</span> intervalPublishMillis = <span class="hljs-number">500</span>;  <span class="hljs-comment">// 时间间隔</span><br><br><span class="hljs-comment">// 定义JSON数据</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* mqtt_ha_config = <span class="hljs-string">R&quot;(&#123;</span><br><span class="hljs-string">   &quot;name&quot;:&quot;小夜灯控制器&quot;,</span><br><span class="hljs-string">   &quot;command_topic&quot;:&quot;HomeAssistant/switch/NightLight/set&quot;,</span><br><span class="hljs-string">   &quot;state_topic&quot;:&quot;HomeAssistant/switch/NightLight/state&quot;,</span><br><span class="hljs-string">   &quot;unique_id&quot;:&quot;NightLight01FC&quot;,</span><br><span class="hljs-string">   &quot;device&quot;:&#123;</span><br><span class="hljs-string">      &quot;identifiers&quot;:[</span><br><span class="hljs-string">         &quot;01FC&quot;</span><br><span class="hljs-string">      ],</span><br><span class="hljs-string">      &quot;name&quot;:&quot;NightLight&quot;</span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string">&#125;)&quot;</span>;<br><br><span class="hljs-comment">// MQTT连接成功后的回调函数</span><br><span class="hljs-comment">// MQTT消息回调函数，该函数会在PubSubClient对象的loop方法中被调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mqtt_callback</span><span class="hljs-params">(<span class="hljs-type">char</span> *topic, byte *payload, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length)</span> &#123;<br>  <span class="hljs-keyword">if</span>(length == <span class="hljs-number">2</span> &amp;&amp; payload[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; payload[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;N&#x27;</span>)&#123;<br>      digitalWrite(RELAY_PIN, LOW); <span class="hljs-comment">//Set the GPIO0 output level to high.线圈打开电力</span><br>      relay_state = <span class="hljs-literal">true</span>;<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(length == <span class="hljs-number">3</span> &amp;&amp; payload[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; payload[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;F&#x27;</span> &amp;&amp; payload[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;F&#x27;</span>)&#123;<br>      digitalWrite(RELAY_PIN, HIGH); <span class="hljs-comment">//Set the GPIO0 output level to high.线圈失去电力</span><br>      relay_state = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//打开串口</span><br>  Serial.begin(<span class="hljs-number">115200</span>);<br>  pinMode(RELAY_PIN,OUTPUT);  <span class="hljs-comment">//Set GPIO0 to output mode.</span><br>  digitalWrite(RELAY_PIN, HIGH); <span class="hljs-comment">//Set the GPIO0 output level to high.线圈失去电力</span><br>  relay_state = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (DEBUG) &#123;<br>    <span class="hljs-comment">// 清除ESP8266所存储的WiFi连接信息以便测试WiFiManager工作效果</span><br>    wifiManager.resetSettings();<br>  &#125;<br>  wifiManager.autoConnect(<span class="hljs-string">&quot;NightLight_01FC&quot;</span>);  <span class="hljs-comment">//连接WiFi</span><br>                                            <span class="hljs-comment">// 设置MQTT服务器和回调函数</span><br>                                            <span class="hljs-comment">// 设置MQTT客户端</span><br>  mqttClient.setClient(espClient);<br>  mqttClient.setServer(mqtt_broker_addr, mqtt_broker_port);<br>  mqttClient.setBufferSize(mqtt_client_buff_size);<br>  mqttClient.setKeepAlive(<span class="hljs-number">60</span>);<br>  mqttClient.setCallback(mqtt_callback);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> currentMillis = millis();  <span class="hljs-comment">// 读取当前时间</span><br>  <span class="hljs-comment">// 连接MQTT服务器</span><br>  <span class="hljs-keyword">if</span> (!mqttClient.connected())  <span class="hljs-comment">// 如果未连接</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (currentMillis - previousConnectMillis &gt; intervalConnectMillis) &#123;<br>      previousConnectMillis = currentMillis;<br>      <span class="hljs-keyword">if</span> (mqttClient.connect(mqtt_client_id, mqtt_username, mqtt_password)) &#123;  <span class="hljs-comment">// 尝试连接服务器</span><br>          mqttClient.publish(mqtt_ha_config_topic,mqtt_ha_config);  <span class="hljs-comment">// 连接成功后可以发送消息</span><br>          mqttClient.subscribe(mqtt_ha_command_topic,<span class="hljs-number">0</span>);<br>          Serial.println(<span class="hljs-string">&quot;MQTT连接成功,配置信息已发送至HA.&quot;</span>);<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        Serial.println(<span class="hljs-string">&quot;MQTT连接失败,请检查配置.&quot;</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 定期发送消息</span><br>  <span class="hljs-keyword">if</span> (mqttClient.connected()) &#123;<br>    <span class="hljs-keyword">if</span> (currentMillis - previousPublishMillis &gt;= intervalPublishMillis)  <span class="hljs-comment">// 如果和前次时间大于等于时间间隔</span><br>    &#123;<br>      previousPublishMillis = currentMillis;<br>      <span class="hljs-keyword">if</span>(relay_state)&#123;<br>         mqttClient.publish(mqtt_ha_state_topic,<span class="hljs-string">&quot;ON&quot;</span>);  <span class="hljs-comment">// 连接成功后可以发送消息</span><br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        mqttClient.publish(mqtt_ha_state_topic,<span class="hljs-string">&quot;OFF&quot;</span>);  <span class="hljs-comment">// 连接成功后可以发送消息</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 处理MQTT事务</span><br>  mqttClient.loop();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h5 id="ESPC3-SuperMini-读取-BH1750-数字光照传感器的值"><a href="#ESPC3-SuperMini-读取-BH1750-数字光照传感器的值" class="headerlink" title="ESPC3 SuperMini 读取 BH1750 数字光照传感器的值"></a>ESPC3 SuperMini 读取 BH1750 数字光照传感器的值</h5></blockquote><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/4.webp" alt="康耀三维科技（深圳）有限公司GY302 BH1750 光强度光照度传感器模块 BH1750FVI"></p><p>使用的是I2C进行通信，5个引脚，分别是</p><table><thead><tr><th>VCC</th><th>供电电压源正极  5V通信</th></tr></thead><tbody><tr><td>SCL</td><td>IIC时钟线，时钟输入引脚，由MCU输出时钟</td></tr><tr><td>SDA</td><td>IIC数据线，双向IO口，用来传输数据</td></tr><tr><td>ADDR</td><td>IIC地址线，&lt; 0.7v 时 地址为0100011 (0x23)，&gt;0.7v 时 器件地址为1011100(0x5c)</td></tr><tr><td>GND</td><td>供电电压源负极</td></tr></tbody></table><p>Arduino有库，我使用的是：</p><p>案例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Advanced BH1750 library usage example</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">This example has some comments about advanced usage features.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Connections</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  - VCC to 3V3 or 5V</span><br><span class="hljs-comment">  - GND to GND</span><br><span class="hljs-comment">  - SCL to SCL (A5 on Arduino Uno, Leonardo, etc or 21 on Mega and Due, on</span><br><span class="hljs-comment">    esp8266 free selectable)</span><br><span class="hljs-comment">  - SDA to SDA (A4 on Arduino Uno, Leonardo, etc or 20 on Mega and Due, on</span><br><span class="hljs-comment">    esp8266 free selectable)</span><br><span class="hljs-comment">  - ADD to (not connected) or GND</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ADD pin is used to set sensor I2C address. If it has voltage greater or equal</span><br><span class="hljs-comment">to 0.7VCC voltage (e.g. you&#x27;ve connected it to VCC) the sensor address will be</span><br><span class="hljs-comment">0x5C. In other case (if ADD voltage less than 0.7 * VCC) the sensor address</span><br><span class="hljs-comment">will be 0x23 (by default).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;BH1750.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Wire.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  BH1750 can be physically configured to use two I2C addresses:</span><br><span class="hljs-comment">    - 0x23 (most common) (if ADD pin had &lt; 0.7VCC voltage)</span><br><span class="hljs-comment">    - 0x5C (if ADD pin had &gt; 0.7VCC voltage)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  Library uses 0x23 address as default, but you can define any other address.</span><br><span class="hljs-comment">  If you had troubles with default value - try to change it to 0x5C.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br>BH1750 <span class="hljs-title function_">lightMeter</span><span class="hljs-params">(<span class="hljs-number">0x23</span>)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br><br>  Serial.begin(<span class="hljs-number">9600</span>);<br><br>  <span class="hljs-comment">// Initialize the I2C bus (BH1750 library doesn&#x27;t do this automatically)</span><br>  Wire.begin(<span class="hljs-number">8</span>,<span class="hljs-number">9</span>); <span class="hljs-comment">//SDA SCL</span><br>  <span class="hljs-comment">// On esp8266 you can select SCL and SDA pins using Wire.begin(D4, D3);</span><br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    BH1750 has six different measurement modes. They are divided in two groups;</span><br><span class="hljs-comment">    continuous and one-time measurements. In continuous mode, sensor</span><br><span class="hljs-comment">    continuously measures lightness value. In one-time mode the sensor makes</span><br><span class="hljs-comment">    only one measurement and then goes into Power Down mode.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Each mode, has three different precisions:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      - Low Resolution Mode - (4 lx precision, 16ms measurement time)</span><br><span class="hljs-comment">      - High Resolution Mode - (1 lx precision, 120ms measurement time)</span><br><span class="hljs-comment">      - High Resolution Mode 2 - (0.5 lx precision, 120ms measurement time)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    By default, the library uses Continuous High Resolution Mode, but you can</span><br><span class="hljs-comment">    set any other mode, by passing it to BH1750.begin() or BH1750.configure()</span><br><span class="hljs-comment">    functions.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [!] Remember, if you use One-Time mode, your sensor will go to Power Down</span><br><span class="hljs-comment">    mode each time, when it completes a measurement and you&#x27;ve read it.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Full mode list:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      BH1750_CONTINUOUS_LOW_RES_MODE</span><br><span class="hljs-comment">      BH1750_CONTINUOUS_HIGH_RES_MODE (default)</span><br><span class="hljs-comment">      BH1750_CONTINUOUS_HIGH_RES_MODE_2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      BH1750_ONE_TIME_LOW_RES_MODE</span><br><span class="hljs-comment">      BH1750_ONE_TIME_HIGH_RES_MODE</span><br><span class="hljs-comment">      BH1750_ONE_TIME_HIGH_RES_MODE_2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-comment">// begin returns a boolean that can be used to detect setup problems.</span><br>  <span class="hljs-keyword">if</span> (lightMeter.begin(BH1750::CONTINUOUS_HIGH_RES_MODE)) &#123;<br>    Serial.println(F(<span class="hljs-string">&quot;BH1750 Advanced begin&quot;</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    Serial.println(F(<span class="hljs-string">&quot;Error initialising BH1750&quot;</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (lightMeter.measurementReady()) &#123;<br>    <span class="hljs-type">float</span> lux = lightMeter.readLightLevel();<br>    Serial.print(<span class="hljs-string">&quot;Light: &quot;</span>);<br>    Serial.print(lux);<br>    Serial.println(<span class="hljs-string">&quot; lx&quot;</span>);<br>  &#125;<br>  delay(<span class="hljs-number">500</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h5 id="ESPC3-SuperMini读取空气质量3合一传感器"><a href="#ESPC3-SuperMini读取空气质量3合一传感器" class="headerlink" title="ESPC3 SuperMini读取空气质量3合一传感器"></a>ESPC3 SuperMini读取空气质量3合一传感器</h5></blockquote><p>购买链接： #小程序:&#x2F;&#x2F;拼多多&#x2F;OcDCOVxnkyN9csf</p><p>实物：</p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/5.webp"></p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/6.webp"></p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/7.webp"></p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/8.webp"></p><p><img src="/img/docs/ESP%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E3%80%81%E5%85%89%E7%85%A7%E3%80%81%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/9.webp"></p><p>代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;HardwareSerial.h&quot;</span></span><br><br><span class="hljs-comment">// 定义串口通信的波特率</span><br><span class="hljs-type">const</span> <span class="hljs-type">long</span> baudRate = <span class="hljs-number">9600</span>;<br><span class="hljs-comment">// 实例化HardwareSerial对象,目前我也不知道这个1具体值得是啥，可能是串口1，usb串口是0</span><br>HardwareSerial <span class="hljs-title function_">mySerial</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>; <br><br>byte airData[<span class="hljs-number">9</span>];<br>byte airIndex = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 计算CRC校验值</span><br>byte <span class="hljs-title function_">calculateCRC</span><span class="hljs-params">(byte data[], <span class="hljs-type">int</span> length)</span> &#123;<br>  byte crc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    crc += data[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> crc;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 初始化默认串口（通常用于调试信息输出）</span><br>  Serial.begin(baudRate);<br>  <span class="hljs-comment">// 初始化自定义串口</span><br>  <span class="hljs-comment">//void HardwareSerial::begin(unsigned long baud, uint32_t config=SERIAL_8N1, int8_t rxPin=-1, int8_t txPin=-1, bool invert=false, unsigned long timeout_ms = 20000UL);</span><br>  mySerial.begin(baudRate, SERIAL_8N1, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20000UL</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (mySerial.available() &gt; <span class="hljs-number">0</span>) &#123;<br>    airData[airIndex++] = mySerial.read();<br>    <span class="hljs-keyword">if</span> (airIndex &gt;= <span class="hljs-number">9</span>) &#123;<br>      <span class="hljs-comment">//溢出，可计算数据！</span><br>      byte calculatedCRC = calculateCRC(airData, airIndex - <span class="hljs-number">1</span>);<br>      byte receivedCRC = airData[airIndex - <span class="hljs-number">1</span>];<br>      <span class="hljs-comment">// 验证CRC校验值</span><br>      <span class="hljs-keyword">if</span> (calculatedCRC == receivedCRC) &#123;<br>        <span class="hljs-comment">// 提取TVOC数据</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> tvoc = (airData[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | airData[<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">// 提取CH₂O数据</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ch2o = (airData[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>) | airData[<span class="hljs-number">5</span>];<br>        <span class="hljs-comment">// 提取CO₂数据</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> co2 = (airData[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">8</span>) | airData[<span class="hljs-number">7</span>];<br><br>        <span class="hljs-comment">// 输出解析结果</span><br>        Serial.print(<span class="hljs-string">&quot;TVOC: &quot;</span>);<br>        Serial.print(tvoc);<br>        Serial.println(<span class="hljs-string">&quot; ppb&quot;</span>);<br><br>        Serial.print(<span class="hljs-string">&quot;CH₂O: &quot;</span>);<br>        Serial.print(ch2o);<br>        Serial.println(<span class="hljs-string">&quot; ppm&quot;</span>);<br><br>        Serial.print(<span class="hljs-string">&quot;CO₂: &quot;</span>);<br>        Serial.print(co2);<br>        Serial.println(<span class="hljs-string">&quot; ppm&quot;</span>);<br>        Serial.println();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        Serial.println(<span class="hljs-string">&quot;CRC check failed!&quot;</span>);<br>      &#125;<br>      airIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//置空</span><br>    &#125;<br>    <span class="hljs-comment">// 使用格式化输出保证每个字节以两位十六进制数显示</span><br>    <span class="hljs-comment">//Serial.printf(&quot;%02X &quot;, airData[airIndex]);</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h5 id="ESPC3-SuperMini-将BH1750-和空气质量传感器与Home-Assistant联动"><a href="#ESPC3-SuperMini-将BH1750-和空气质量传感器与Home-Assistant联动" class="headerlink" title="ESPC3 SuperMini 将BH1750 和空气质量传感器与Home Assistant联动"></a>ESPC3 SuperMini 将BH1750 和空气质量传感器与Home Assistant联动</h5></blockquote><p>直接附上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WiFiManager.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;BH1750.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Wire.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;PubSubClient.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ArduinoJson.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;HardwareSerial.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_broker_addr <span class="hljs-string">&quot;192.168.0.200&quot;</span>  <span class="hljs-comment">//MQTT服务器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_broker_port  1883          <span class="hljs-comment">//mqtt端口，默认1883</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_username <span class="hljs-string">&quot;lqzhi&quot;</span>             <span class="hljs-comment">//MQTT的账户</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_password <span class="hljs-string">&quot;lqzhi_password&quot;</span>    <span class="hljs-comment">//MQTT的密码</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_client_buff_size 1024     <span class="hljs-comment">// 客户端缓存大小（非必须）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_ha_light_config_topic <span class="hljs-string">&quot;LQZHI/sensor/Light/config&quot;</span>  <span class="hljs-comment">//光照传感器状态配置</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_ha_light_state_topic <span class="hljs-string">&quot;LQZHI/sensor/Light/state&quot;</span>   <span class="hljs-comment">//光照传感器状态配置</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_ha_air_tovc_config_topic <span class="hljs-string">&quot;LQZHI/sensor/AirTOVC/config&quot;</span>  <span class="hljs-comment">//光照传感器状态配置</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_ha_air_ch2o_config_topic <span class="hljs-string">&quot;LQZHI/sensor/AirCH2O/config&quot;</span>  <span class="hljs-comment">//光照传感器状态配置</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_ha_air_co2_config_topic <span class="hljs-string">&quot;LQZHI/sensor/AirCO2/config&quot;</span>  <span class="hljs-comment">//光照传感器状态配置</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_ha_air_state_topic <span class="hljs-string">&quot;LQZHI/sensor/Air/state&quot;</span>    <span class="hljs-comment">//光照传感器状态配置</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mqtt_client_id <span class="hljs-string">&quot;ORANGEPI_BH1750_AIR_SERSOR&quot;</span>                    <span class="hljs-comment">//客户端ID</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  previousConnectMillis = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 毫秒时间记录</span><br><span class="hljs-type">const</span> <span class="hljs-type">long</span> PROGMEM intervalConnectMillis = <span class="hljs-number">5000</span>;  <span class="hljs-comment">// 时间间隔  //此变量不变，放入到FLASH中减轻压力</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> previousPublishMillis = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 毫秒时间记录</span><br><span class="hljs-type">const</span> <span class="hljs-type">long</span> PROGMEM intervalPublishMillis = <span class="hljs-number">1000</span>;  <span class="hljs-comment">// 时间间隔  //此变量不变，放入到FLASH中减轻压力</span><br><br>WiFiClient espClient;<br>PubSubClient mqttClient;<br>BH1750 <span class="hljs-title function_">lightMeter</span><span class="hljs-params">(<span class="hljs-number">0x23</span>)</span>;<br>HardwareSerial <span class="hljs-title function_">mySerial</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>;<br><br>byte airData[<span class="hljs-number">9</span>];<br>byte airIndex = <span class="hljs-number">0</span>;<br><span class="hljs-type">double</span> tvoc,ch2o;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> co2;<br><br><span class="hljs-comment">// 计算CRC校验值</span><br>byte <span class="hljs-title function_">calculateCRC</span><span class="hljs-params">(byte data[], <span class="hljs-type">int</span> length)</span> &#123;<br>  byte crc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    crc += data[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> crc;<br>&#125;<br><br><span class="hljs-comment">//生产HA的Config</span><br>String <span class="hljs-title function_">generateHAConfig</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* stateTopic, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* uniqueId, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* unit, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* valueTemplate, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* deviceId, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* deviceName)</span> &#123;<br>    DynamicJsonDocument <span class="hljs-title function_">doc</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span>;<br>    doc[<span class="hljs-string">&quot;name&quot;</span>] = name;<br>    doc[<span class="hljs-string">&quot;state_topic&quot;</span>] = stateTopic;<br>    doc[<span class="hljs-string">&quot;unique_id&quot;</span>] = uniqueId;<br>    doc[<span class="hljs-string">&quot;unit_of_measurement&quot;</span>] = unit;<br>    <span class="hljs-keyword">if</span> (valueTemplate != nullptr) &#123;<br>        doc[<span class="hljs-string">&quot;value_template&quot;</span>] = valueTemplate;<br>    &#125;<br>    JsonObject device = doc.createNestedObject(<span class="hljs-string">&quot;device&quot;</span>);<br>    JsonArray identifiers = device.createNestedArray(<span class="hljs-string">&quot;identifiers&quot;</span>);<br>    identifiers.add(deviceId);<br>    device[<span class="hljs-string">&quot;name&quot;</span>] = deviceName;<br>    String jsonString;<br>    serializeJson(doc, jsonString);<br>    <span class="hljs-keyword">return</span> jsonString;<br>&#125;<br><br><span class="hljs-comment">//生产Air的JSON字符串</span><br>String <span class="hljs-title function_">generateAirJson</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个动态的 JSON 文档，指定合适的容量</span><br>    DynamicJsonDocument <span class="hljs-title function_">doc</span><span class="hljs-params">(<span class="hljs-number">256</span>)</span>; <br><br>    <span class="hljs-comment">// 向 JSON 对象中添加数据</span><br>    doc[<span class="hljs-string">&quot;tovc&quot;</span>] = tvoc;<br>    doc[<span class="hljs-string">&quot;ch2o&quot;</span>] = ch2o;<br>    doc[<span class="hljs-string">&quot;co2&quot;</span>] = co2;<br><br>    <span class="hljs-comment">// 用于存储序列化后的 JSON 字符串</span><br>    String jsonString; <br>    <span class="hljs-comment">// 将 JSON 文档序列化为字符串</span><br>    serializeJson(doc, jsonString); <br><br>    <span class="hljs-keyword">return</span> jsonString;<br>&#125;    <br><span class="hljs-type">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//初始化串口</span><br>  Serial.begin(<span class="hljs-number">9600</span>);<br>   <span class="hljs-comment">//配置网络</span><br>  WiFiManager wifiManager;<br>  wifiManager.setConfigPortalTimeout(<span class="hljs-number">180</span>);<br>  <span class="hljs-keyword">if</span>(!wifiManager.autoConnect()) &#123; <br>    Serial.println(<span class="hljs-string">&quot;failed to connect and hit timeout&quot;</span>);<br>    delay(<span class="hljs-number">3000</span>);<br>    <span class="hljs-comment">//reset and try again, or maybe put it to deep sleep</span><br>    ESP.restart();<br>    delay(<span class="hljs-number">5000</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//初始化mqtt</span><br>  mqttClient.setClient(espClient);<br>  mqttClient.setServer(mqtt_broker_addr, mqtt_broker_port);<br>  mqttClient.setBufferSize(mqtt_client_buff_size);<br>  mqttClient.setKeepAlive(<span class="hljs-number">60</span>);<br><br>  <span class="hljs-comment">//初始化串口</span><br>  mySerial.begin(<span class="hljs-number">9600UL</span>, SERIAL_8N1, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">20000UL</span>);<br><br>  Wire.begin(<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);<br>  <span class="hljs-comment">//初始化配置Light</span><br>  <span class="hljs-keyword">if</span> (lightMeter.begin(BH1750::CONTINUOUS_HIGH_RES_MODE)) &#123;<br>    Serial.println(F(<span class="hljs-string">&quot;BH1750 Advanced begin&quot;</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    Serial.println(F(<span class="hljs-string">&quot;Error initialising BH1750&quot;</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> currentMillis = millis();  <span class="hljs-comment">// 读取当前时间</span><br><span class="hljs-comment">// 连接MQTT服务器</span><br>  <span class="hljs-keyword">if</span> (!mqttClient.connected())  <span class="hljs-comment">// 如果未连接</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (currentMillis - previousConnectMillis &gt; intervalConnectMillis) &#123;<br>      previousConnectMillis = currentMillis;<br>      <span class="hljs-keyword">if</span> (mqttClient.connect(mqtt_client_id, mqtt_username, mqtt_password)) &#123;  <span class="hljs-comment">// 尝试连接服务器</span><br>         <span class="hljs-comment">//使用大括号现在临时变量的使用范围</span><br>         &#123;<br><br>           <span class="hljs-comment">//光照度</span><br>          String lightConfig  = generateHAConfig(<span class="hljs-string">&quot;光照传感器&quot;</span>, mqtt_ha_light_state_topic, <span class="hljs-string">&quot;Light01FB&quot;</span>, <span class="hljs-string">&quot;Lux&quot;</span>, nullptr, <span class="hljs-string">&quot;01FB&quot;</span>, <span class="hljs-string">&quot;Light&quot;</span>);<br>          mqttClient.publish(mqtt_ha_light_config_topic,lightConfig.c_str());  <span class="hljs-comment">// 连接成功后可以发送消息</span><br>          lightConfig = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//清空内存</span><br>          <span class="hljs-comment">//TOVC</span><br>          String airTOVCConfig = generateHAConfig(<span class="hljs-string">&quot;TOVC&quot;</span>, mqtt_ha_air_state_topic, <span class="hljs-string">&quot;Air01FA&quot;</span>, <span class="hljs-string">&quot;mg/m³&quot;</span>, <span class="hljs-string">&quot;&#123;&#123; value_json.tovc&#125;&#125;&quot;</span>, <span class="hljs-string">&quot;01FA&quot;</span>, <span class="hljs-string">&quot;Air&quot;</span>);<br>          mqttClient.publish(mqtt_ha_air_tovc_config_topic,airTOVCConfig.c_str());  <span class="hljs-comment">// 连接成功后可以发送消息</span><br>          airTOVCConfig = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//清空内存</span><br>          <span class="hljs-comment">//CH20</span><br>          String airCH2OConfig = generateHAConfig(<span class="hljs-string">&quot;CH2O&quot;</span>, mqtt_ha_air_state_topic, <span class="hljs-string">&quot;Air01F9&quot;</span>, <span class="hljs-string">&quot;mg/m³&quot;</span>, <span class="hljs-string">&quot;&#123;&#123; value_json.ch2o&#125;&#125;&quot;</span>, <span class="hljs-string">&quot;01F9&quot;</span>, <span class="hljs-string">&quot;Air&quot;</span>);<br>          mqttClient.publish(mqtt_ha_air_ch2o_config_topic,airCH2OConfig.c_str());  <span class="hljs-comment">// 连接成功后可以发送消息</span><br>          airCH2OConfig = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//清空内存</span><br>          <span class="hljs-comment">//CO2</span><br>          String airCO2Config = generateHAConfig(<span class="hljs-string">&quot;CO2&quot;</span>, mqtt_ha_air_state_topic, <span class="hljs-string">&quot;Air01F8&quot;</span>, <span class="hljs-string">&quot;ppm&quot;</span>, <span class="hljs-string">&quot;&#123;&#123; value_json.co2&#125;&#125;&quot;</span>, <span class="hljs-string">&quot;01F8&quot;</span>, <span class="hljs-string">&quot;Air&quot;</span>);<br>          mqttClient.publish(mqtt_ha_air_co2_config_topic,airCO2Config.c_str());  <span class="hljs-comment">// 连接成功后可以发送消息</span><br>          airCO2Config = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//清空内存</span><br>          Serial.println(<span class="hljs-string">&quot;MQTT连接成功,配置信息已发送至HA.&quot;</span>);<br><br>         &#125;<br><br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 定期发送消息</span><br>  <span class="hljs-keyword">if</span> (mqttClient.connected()) &#123;<br>    <span class="hljs-keyword">if</span> (currentMillis - previousPublishMillis &gt;= intervalPublishMillis)  <span class="hljs-comment">// 如果和前次时间大于等于时间间隔</span><br>    &#123;<br>      previousPublishMillis = currentMillis;<br><br>     <span class="hljs-comment">//同理,使用大括号现在临时变量的声明周期</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (lightMeter.measurementReady()) &#123;<br>          <span class="hljs-type">float</span> lux = lightMeter.readLightLevel();<br>          <span class="hljs-comment">//Serial.printf(&quot;Light: %f Lux\n&quot;,lux);</span><br>          <span class="hljs-comment">//发送信息</span><br>          mqttClient.publish(mqtt_ha_light_state_topic, String(lux).c_str()); <br>        &#125;<br><br>        String airString = generateAirJson();<br>        <span class="hljs-comment">//Serial.printf(&quot;Air Json: %s \n&quot;,airString);</span><br>        mqttClient.publish(mqtt_ha_air_state_topic, airString.c_str());<br>        airString = <span class="hljs-string">&quot;&quot;</span>;<br>      &#125;<br><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// if (lightMeter.measurementReady()) &#123;</span><br>  <span class="hljs-comment">//   float lux = lightMeter.readLightLevel();</span><br>  <span class="hljs-comment">//   Serial.print(&quot;Light: &quot;);</span><br>  <span class="hljs-comment">//   Serial.print(lux);</span><br>  <span class="hljs-comment">//   Serial.println(&quot; lx&quot;);</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// delay(500);</span><br><br>   <span class="hljs-keyword">if</span> (mySerial.available() &gt; <span class="hljs-number">0</span>) &#123;<br>    airData[airIndex++] = mySerial.read();<br>    <span class="hljs-keyword">if</span> (airIndex &gt;= <span class="hljs-number">9</span>) &#123;<br>      <span class="hljs-comment">//溢出，可计算数据！</span><br>      byte calculatedCRC = calculateCRC(airData, airIndex - <span class="hljs-number">1</span>);<br>      byte receivedCRC = airData[airIndex - <span class="hljs-number">1</span>];<br>      <span class="hljs-comment">//Serial.printf(&quot;calculatedCRC = %02X,receivedCRC = %02X&quot;,calculatedCRC,receivedCRC);</span><br>      <span class="hljs-comment">// 验证CRC校验值</span><br>      <span class="hljs-keyword">if</span> (calculatedCRC == receivedCRC) &#123;<br>        <span class="hljs-comment">// 提取TVOC数据</span><br>        tvoc = ((airData[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | airData[<span class="hljs-number">3</span>]) * <span class="hljs-number">0.001</span>;<br>        <span class="hljs-comment">// 提取CH₂O数据</span><br>        ch2o = ((airData[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>) | airData[<span class="hljs-number">5</span>]) * <span class="hljs-number">0.001</span>;<br>        <span class="hljs-comment">// 提取CO₂数据</span><br>        co2 = (airData[<span class="hljs-number">6</span>] &lt;&lt; <span class="hljs-number">8</span>) | airData[<span class="hljs-number">7</span>];<br>        <span class="hljs-comment">//Serial.printf(&quot;TVOC:%lf,CH20:%lf,co2:%ld&quot;,tvoc,ch2o,co2);</span><br>        <span class="hljs-comment">// // 输出解析结果</span><br>        <span class="hljs-comment">// Serial.print(&quot;TVOC: &quot;);</span><br>        <span class="hljs-comment">// Serial.print(tvoc);</span><br>        <span class="hljs-comment">// Serial.println(&quot; ppb&quot;);</span><br><br>        <span class="hljs-comment">// Serial.print(&quot;CH₂O: &quot;);</span><br>        <span class="hljs-comment">// Serial.print(ch2o);</span><br>        <span class="hljs-comment">// Serial.println(&quot; ppm&quot;);</span><br><br>        <span class="hljs-comment">// Serial.print(&quot;CO₂: &quot;);</span><br>        <span class="hljs-comment">// Serial.print(co2);</span><br>        <span class="hljs-comment">// Serial.println(&quot; ppm&quot;);</span><br>        <span class="hljs-comment">// Serial.println();</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><br><br>        Serial.println(<span class="hljs-string">&quot;CRC check failed!&quot;</span>);<br>      &#125;<br><br>      airIndex = <span class="hljs-number">0</span>;<span class="hljs-comment">//置空</span><br>    &#125;<br>    <span class="hljs-comment">// 使用格式化输出保证每个字节以两位十六进制数显示</span><br>    <span class="hljs-comment">//Serial.printf(&quot;%02X &quot;, airData[airIndex]);</span><br>  &#125;<br><br>    <span class="hljs-comment">// 处理MQTT事务</span><br>  mqttClient.loop();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>至此，空气传感器，继电器，光照传感器到这里就结束啦。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ESP8266</category>
      
      <category>ESP32</category>
      
      <category>HomeAssistant</category>
      
      <category>代码记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建一份属于你的博客吧</title>
    <link href="/2020/11/20/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/"/>
    <url>/2020/11/20/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这是一篇使用GitHub Pages + Hexo搭建自己博客的笔记。内容会尽可能的详细,因为怕自己哪天就忘记了。</p><p>在搭建之前,我们需要了解一下GitHub Pages 和Hexo。</p><p><a href="https://pages.github.com/">Github Pages</a></p><p>&emsp;&emsp;相信会编程的人都知道一个网站 <a href="https://github.com/">github</a> ，这是一个面向开源及私有软件项目的托管平台。这是一个拥有百万程序员的网站，许多人都将自己的代码开源，并将代码托管给github。而GitHub Pages，则是github提供给用户用来展示个人或者项目主页的静态网页系统。也就是说，自己可以搭建一个静态的网页，将其交给GitHub Pages去呈现。就相当于一个微型服务器啦,重点是，这玩意是免费的.</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/1.webp"></p><p><a href="https://hexo.io/zh-cn/index.html">Hexo</a></p><p>Hexo是一个快速，简洁且高效的博客框架。其能够根据配置，主题，原始数据能够自动生成静态网页，而且Hexo还支持Github Flavored Markdown的所有功能,，外加一些强大的框架(网站数据统计,评论系统等等)。所以,我们就用Hexo生成静态网页，再将其发布到GitHub Pages上，最后由GitHub Pages展现出来。</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/2.webp"></p><p><a href="https://markdown.com.cn/">markdown</a></p><p>MarkDown，这里需要提及一下，因为Hexo的原始博客数据是由MardDown编写的，所以写博客的话需要了解一下MarkDown的语法。那么MarkDown是什么呢？这里引用<a href="https://markdown.com.cn/">MarkDown语法教程</a>的一句话：Markdown是一种轻量级的「标记语言」，通常为程序员群体所用，目前它已是全球最大的技术分享网站 GitHub 和技术问答网站 StackOverFlow 的御用书写格式。MarkDown可以让你专注你的文字内容而不是排版样式，使其编写出美观，直观可读的文本。</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/3.webp"></p><p>好了，当了解了这些之后，我们便可以开始搭建一下自己的小博客网站了。</p><ol><li>创建一个Github账户</li></ol><p>因为GitHub Pages是GitHub提供的，所以我们理所当然的需要一个GitHub账户。创建GitHub是一个很简单的过程，这里也不会多说，就是一个普通的使用邮箱创建账户罢了。<strong>但是需要注意的是，用户名不能随便起哦，一定要想好，想清楚再起哦。一方面是因为GitHUb Pages提供的域名(网站名)是用户名.github.io，另一方面是在GitHub中改用户名很麻烦的。</strong></p><p><a href="https://github.com/join">Sign up to GitHub · GitHub</a></p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/4.webp"></p><ol start="2"><li>登录Github网站</li></ol><p><a href="https://github.com/">点击我登录Github网站</a></p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/5.webp"></p><ol start="3"><li>创建一个仓库</li></ol><p>创建一个GitHub仓库，用于搭建GitHub Pages，当然，这个仓库名不能随便乱起，必须是用户名.github.io。</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/6.webp"></p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/7.webp"></p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/8.webp"></p><p>创建好之后的大概的样子.（因为我已经发布了文件,所以可能不一样。）</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/9.webp"></p><ol start="5"><li>下载Node.js</li></ol><p>  因为Hexo是需要Node.js环境的，所以我们需要下载安装Node.js。</p><p>  根据<a href="http://nodejs.cn/download/">Node.js下载官网</a>自己选择相对应的Node.js包即可。 </p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/10.webp"></p><ol start="6"><li>判断是否环境配置完成</li></ol><p>&emsp;&emsp;打开Cmd(命令控制台),然后输入<strong>node -v</strong>,当出现版本号时,则Node.js安装完成.然后输入<strong>npm -v</strong>,检测npm包管理器是否正常.</p><p>如下图所示</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/11.webp"></p><p>当然,也可以点击以下链接了解以下</p><p><a href="https://jingyan.baidu.com/article/20095761e58096cb0721b4fc.html">百度知道-如何检查Node.js是否安装正常</a></p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">菜鸟教程-Node.js 安装配置</a></p><p><a href="https://www.cnblogs.com/xt-Corrine/p/10812503.html">博客园-Node.js安装及环境配置</a></p><ol start="7"><li>安装Hexo</li></ol><p> 推荐查看<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>进行学习.安装Hexo很简单,只需要打开Cmd,然后输入<strong>npm install -g hexo-cli</strong>,回车即可.然后不出意外的话,一会儿就会安装完成(因为我已经安装过一次了,所以也没办法截图.).然后我们检测一下Hexo是否安装成功.</p><p>  我们在Cmd中,输入<strong>hexo -v</strong>,回车后会出现Hexo版本的一些信息.(如果没有的话,就输入<strong>npx hexo -v</strong>.因为Hexo的环境变量没有配置好,所以就无法直接使用hexo指令,不过我们完全可以使用npx来调用执行hexo.)</p><p>如图</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/12.webp"></p><p>可以看看这些博客：<a href="https://www.jianshu.com/p/09875c4a629c">简书-hexo安装与配置</a></p><ol start="8"><li>安装Git</li></ol><p>&emsp;&emsp;因为Hexo生成的静态网页文件需要上传到Github上面,所以Git当然是必不可少的啦.我们需要安装Git.(同上,Git已经安装过了,所以没办法截图.不过需要注意的是,Git下载有个PortableGit,这是一个免安装版本,下载后运行,选择安装目录,然后配置环境就可以使用了.方便了许多.)</p><p><a href="https://git-scm.com/downloads">Git下载官网</a></p><p><a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝的Git镜像网站</a></p><p>(<strong>推荐使用淘宝的Git镜像网站,下载会快一点,往下面拉,选择最新版本哦~</strong>)</p><p>可以看看这些博客</p><p><a href="https://www.jianshu.com/p/bebba0d8038e">简书-Git安装教程（详细）</a></p><p><a href="https://www.cnblogs.com/ximiaomiao/p/7140456.html">博客园-Git安装和使用</a></p><p><a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程-Git</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">廖雪峰的官方网站-Git教程中的安装Git</a></p><ol start="9"><li>初始化Hexo博客目录</li></ol><p>&emsp;&emsp;打开一个文件目录.选中你心仪的文件夹.例如我选择了D盘,初始化一个名为blog的博客目录.就是在Cmd命令中,输入<strong>hexo init blog</strong>或者<strong>npx hexo init blog</strong>,进行初始化博客目录.这时,hexo就开始下载.下载完成后,就自动帮你创建一个名为blog的文件夹.</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/13.webp"></p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/14.webp"></p><ol start="10"><li>修改Hexo的配置文件</li></ol><p>推荐查看<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>进行学习配置Hexo的配置文件.在博客目录中,有着一个_config.yml文件,这个文件就是Hexo的配置文件.</p><p>我的Hexo配置文件</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs clean"># Hexo Configuration<br>## Docs: https:<span class="hljs-comment">//hexo.io/docs/configuration.html</span><br>## Source: https:<span class="hljs-comment">//github.com/hexojs/hexo/</span><br><br># Site<br>title: 筏执的小课本 #网站标题<br>subtitle: <span class="hljs-string">&#x27;青春激昂,裙角撩人&#x27;</span> #网站副标题<br>description: <span class="hljs-string">&#x27;&#x27;</span> #网站描述<br>keywords: #网站的关键词。支援多个关键词。<br>author: 筏执 #您的名字<br>language: zh-CN #网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。<br>timezone: <span class="hljs-string">&#x27;UTC&#x27;</span> #网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。<br><br># URL<br>## If your site is put <span class="hljs-keyword">in</span> a subdirectory, set url <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;http://example.com/child&#x27;</span> and root <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;/child/&#x27;</span><br>url: http:<span class="hljs-comment">//example.com #网址, must starts with http:// or https://</span><br>root: / #网站根目录<br>permalink: :year/:month/:day/:title/ #文章的 永久链接 格式<br>permalink_defaults: #永久链接中各部分的默认值<br>pretty_urls: #改写 permalink 的值来美化 URL<br>  trailing_index: true # Set to false to remove trailing <span class="hljs-string">&#x27;index.html&#x27;</span> <span class="hljs-keyword">from</span> permalinks(是否在永久链接中保留尾部的 index.html，设置为 false 时去除)<br>  trailing_html: true # Set to false to remove trailing <span class="hljs-string">&#x27;.html&#x27;</span> <span class="hljs-keyword">from</span> permalinks(是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效))<br><br># Directory<br>source_dir: source #资源文件夹，这个文件夹用来存放内容<br>public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件。<br>tag_dir: tags #标签文件夹<br>archive_dir: archives #归档文件夹<br>category_dir: categories #分类文件夹<br>code_dir: downloads/<span class="hljs-keyword">code</span> #Include <span class="hljs-keyword">code</span> 文件夹，source_dir 下的子目录<br>i18n_dir: :lang #国际化（i18n）文件夹<br>#skip_render：跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。<br>#skip_render: <span class="hljs-string">&quot;mypage/**/*&quot;</span><br># 将会直接将 `source/mypage/index.html` 和 `source/mypage/<span class="hljs-keyword">code</span>.js` 不做改动地输出到 <span class="hljs-string">&#x27;public&#x27;</span> 目录<br># 你也可以用这种方法来跳过对指定文章文件的渲染<br>#skip_render: <span class="hljs-string">&quot;_posts/test-post.md&quot;</span><br># 这将会忽略对 <span class="hljs-string">&#x27;test-post.md&#x27;</span> 的渲染<br>#如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。<br>skip_render:                         <br><br># Writing<br>new_post_name: :title.md # File name <span class="hljs-keyword">of</span> new posts(新文章的文件名称)<br>default_layout: post #(预设布局)<br>auto_spacing: true #在中文和英文之间加入空格<br>titlecase: false # Transform title into titlecase #(把标题转换为 title <span class="hljs-keyword">case</span>)<br>external_link: #在新标签中打开链接<br>  enable: true # Open external links <span class="hljs-keyword">in</span> new tab(对整个网站（site）生效或仅对文章（post）生效)<br>  field: site # Apply to the whole site(对整个网站（site）生效或仅对文章（post）生效)<br>  exclude: <span class="hljs-string">&#x27;&#x27;</span> #需要排除的域名。主域名和子域名如 www 需分别配置<br>filename_case: <span class="hljs-number">0</span> #把文件名称转换为 (<span class="hljs-number">1</span>) 小写或 (<span class="hljs-number">2</span>) 大写 (<span class="hljs-number">0</span>)不需要<br>render_drafts: false #显示草稿<br>post_asset_folder: false #启动 Asset 文件夹<br>relative_link: false #把链接改为与根目录的相对位址<br>future: true #显示未来的文章<br>highlight: #代码块的设置<br>  enable: true<br>  line_number: true<br>  auto_detect: false<br>  tab_replace: <span class="hljs-string">&#x27;&#x27;</span><br>  wrap: true<br>  hljs: false<br>prismjs: #代码块的设置, see PrismJS section for usage guide<br>  enable: false<br>  preprocess: true<br>  line_number: true<br>  tab_replace: <span class="hljs-string">&#x27;&#x27;</span><br><br>#默认情况下，Hexo 生成的超链接都是绝对地址。<br>#例如，如果您的网站域名为 example.com,您有一篇文章名为 hello，那么绝对链接可能像这样：http:<span class="hljs-comment">//example.com/hello.html，它是绝对于域名的。</span><br>#相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。<br><br># Home page setting<br># path: Root path for your blogs index page. (default = <span class="hljs-string">&#x27;&#x27;</span>)(您的博客索引页的根路径。)<br># per_page: Posts displayed per page. (<span class="hljs-number">0</span> = disable pagination)(每页显示的文章。(<span class="hljs-number">0</span> =禁用分页))<br># order_by: Posts order. (Order by date descending by default)(文章的顺序。(默认按日期降序排列))<br>index_generator:<br>  path: <span class="hljs-string">&#x27;&#x27;</span><br>  per_page: <span class="hljs-number">10</span><br>  order_by: -date<br><br># Category &amp; Tag<br>default_category: uncategorized #默认分类<br>category_map: #分类别名<br>tag_map: #标签别名<br><br># Metadata elements<br>## https:<span class="hljs-comment">//developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br>meta_generator: true<br><br># Date / Time format<br>## Hexo uses Moment.js to parse and display date<br>## You can customize the date format <span class="hljs-keyword">as</span> defined <span class="hljs-keyword">in</span><br>## http:<span class="hljs-comment">//momentjs.com/docs/#/displaying/format/</span><br>date_format: YYYY-MM-DD #日期格式<br>time_format: HH:mm:ss #时间格式<br>## updated_option supports <span class="hljs-string">&#x27;mtime&#x27;</span>, <span class="hljs-string">&#x27;date&#x27;</span>, <span class="hljs-string">&#x27;empty&#x27;</span><br>updated_option: <span class="hljs-string">&#x27;mtime&#x27;</span> #(当Front Matter 中没有指定updated时updated的取值)<br><br># Pagination<br>## Set per_page to <span class="hljs-number">0</span> to disable pagination<br>per_page: <span class="hljs-number">10</span> #每页显示的文章量(<span class="hljs-number">0</span>为关闭分页功能)<br>pagination_dir: page #分页目录<br><br># Include / Exclude file(s)<br>## include:/exclude: options only apply to the <span class="hljs-string">&#x27;source/&#x27;</span> folder<br><br>#include配置：<br>## Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。<br>## 通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。<br># 举例<br># Include/Exclude Files/Folders<br># include:<br>#  - <span class="hljs-string">&quot;.nojekyll&quot;</span><br># # 包括 <span class="hljs-string">&#x27;source/css/_typing.css&#x27;</span><br>#  - <span class="hljs-string">&quot;css/_typing.css&quot;</span><br>#  # 包括 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件，但不包括子目录及其其中的文件。<br>#  - <span class="hljs-string">&quot;_css/*&quot;</span><br>#  # 包含 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件和子目录下的任何文件<br>#  - <span class="hljs-string">&quot;_css/**/*&quot;</span><br>#<br>#exclude:<br>#  # 不包括 <span class="hljs-string">&#x27;source/js/test.js&#x27;</span><br>#  - <span class="hljs-string">&quot;js/test.js&quot;</span><br>#  # 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件、但包括子目录下的所有目录和文件<br>#  - <span class="hljs-string">&quot;js/*&quot;</span><br>#  # 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件和子目录下的任何文件<br>#  - <span class="hljs-string">&quot;js/**/*&quot;</span><br>#  # 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 目录下的所有文件名以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件，但包括其它文件和子目录下的单文件<br>#  - <span class="hljs-string">&quot;js/test*&quot;</span><br>#  # 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 及其子目录中任何以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件<br>#  - <span class="hljs-string">&quot;js/**/test*&quot;</span><br>#  # 不要用 exclude 来忽略 <span class="hljs-string">&#x27;source/_posts/&#x27;</span> 中的文件。你应该使用 <span class="hljs-string">&#x27;skip_render&#x27;</span>，或者在要忽略的文件的文件名之前加一个下划线 <span class="hljs-string">&#x27;_&#x27;</span><br>#  # 在这里配置一个 - <span class="hljs-string">&quot;_posts/hello-world.md&quot;</span> 是没有用的。<br>#<br>#ignore:<br>#  # Ignore any folder named <span class="hljs-string">&#x27;foo&#x27;</span>.<br>#  - <span class="hljs-string">&quot;**/foo&quot;</span><br>#  # Ignore <span class="hljs-string">&#x27;foo&#x27;</span> folder <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;themes/&#x27;</span> only.<br>#  - <span class="hljs-string">&quot;**/themes/*/foo&quot;</span><br>#  # Same <span class="hljs-keyword">as</span> above, but applies to every subfolders <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;themes/&#x27;</span>.<br>#  - <span class="hljs-string">&quot;**/themes/**/foo&quot;</span><br>include:<br>exclude: #Hexo 会忽略这些文件和目录<br>ignore: #Ignore files/folders<br><br><br># Extensions<br>## Plugins: https:<span class="hljs-comment">//hexo.io/plugins/</span><br>## Themes: https:<span class="hljs-comment">//hexo.io/themes/</span><br>theme: landscape #当前主题名称。值为false时禁用主题<br>#theme_config：#主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置<br><br># Deployment<br>## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span><br>##(部署部分的设置)<br>deploy:<br>  type: git<br>  repo: #git的链接<br>  branch: master<br></code></pre></td></tr></table></figure><ol start="11"><li>Hexo的一些命令了解和使用</li></ol><p> 在进入Hexo博客目录之前,我们在Cmd中输入<strong>hexo help</strong>,就弹出了如下的信息.</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/15.webp"></p><p>1.hexo help : 弹出帮助指令</p><p>2.hexo init 博客目录名: 初始化博客目录</p><p>3.hexo version : hexo版本信息</p><p>  在进入Hexo博客目录之后,我们在Cmd中输入<strong>hexo help</strong>,就弹出了如下的信息.</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/16.webp"></p><ul><li><p>hexo clean : 清除生成的博客网站信息包括文件</p></li><li><p>hexo config : 查看配置文件</p></li><li><p>hexo deploy : 部署你的网站</p></li><li><p>hexo generate : 生成静态博客网站文件</p></li><li><p>hexo help : 帮助</p></li><li><p>hexo init : 初始化博客目录</p></li><li><p>hexo list : 列出站点信息</p></li><li><p>hexo migrate : 将您的站点从其他系统迁移到Hexo</p></li><li><p>hexo new 文章名 : 创建一个post类型的文章</p></li><li><p>hexo server : 开启服务器预览</p><p>主要的还是<strong>hexo clean</strong>,<strong>hexo deploy</strong>,<strong>hexo generate</strong>,<strong>hexo server</strong>,<strong>hexo new 文章名</strong>这些。</p><p>当生成静态博客时,推荐使用<strong>hexo clean &amp; hexo generate</strong> 或 <strong>hexo clean &amp; hexo g</strong>;</p><p>当生成静态博客并且预览时,推荐使用<strong>hexo clean &amp; hexo generate &amp; hexo server</strong> 或 <strong>hexo clean &amp; hexo g &amp; hexo s</strong>;</p><p>当生成静态博客并且部署时,推荐使用<strong>hexo clean &amp; hexo generate &amp; hexo deploy</strong> 或 <strong>hexo clean &amp; hexo g &amp; hexo d</strong>;</p><p>当生成静态博客并且部署时,推荐使用hexo clean &amp; hexo generate &amp; hexo deploy 或 hexo clean &amp; hexo g &amp; hexo d;</p></li></ul><ol start="12"><li>使用Hexo生成文章</li></ol><p>&emsp;&emsp;在博客目录下,使用Cmd,输入<strong>hexo new 文章名</strong>或者<strong>npx hexo new 文章名</strong>,即可创建一个文章,然后在<strong>source</strong>的目录下,找到**_post**目录下带有文章名.md文件,打开编辑即可.</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/17.webp"></p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/18.webp"></p><p>然后编辑md文件即可，如果需要删除文章，只需要删除文件即可。</p><ol start="13"><li>部署Hexo博客到GitHub Pages上面</li></ol><p>&emsp;&emsp;在部署之前，我们需要先在博客目录下，打开cmd，输入<strong>npm install hexo-deployer-git –save</strong>安装插件。然后在博客目录找到**_config.yml**文件,打开,找到以下信息:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br></code></pre></td></tr></table></figure><p>修改成这样</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">GitHub仓库的git地址</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>GitHub仓库的git地址查看方式</p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/19.webp"></p><p><img src="/img/docs/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BB%BD%E5%B1%9E%E4%BA%8E%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/20.webp"></p><p>修改完成配置完成后,保存,然后执行 <strong>hexo clean &amp; hexo g &amp; hexo d</strong>即可生成静态网站.</p><ol start="14"><li>主题</li></ol><p>我使用的是fluid主题。这是<a href="https://github.com/fluid-dev/hexo-theme-fluid">地址</a>,这里就不再累赘了.</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发前你需要了解的一些资料(二)</title>
    <link href="/2020/02/24/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/"/>
    <url>/2020/02/24/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>&emsp;&emsp;在<a href="https://lqzhi.github.io/2020/02/16/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/">安卓开发 开发前你需要了解的一些资料(一)</a>中我们简单的介绍了JDK、SDK、NDK以及开发App的工程结构和Android Studio的部分使用方法。而在本次记录中，将会讲解在开发中<strong>必须要了解的一些资料</strong>以及编写Android 的Hello World(不使用模板)！</p><blockquote><p>Android系统架构</p></blockquote><p>&emsp;&emsp;安卓Android作为一个移动设备的开发平台，其系统构架被分成了四个部分,从高到低分别是：<strong>Android 应用层，Android 应用框架层，Android 系统运行层，Linux 内核层</strong>。</p><p>&emsp;&emsp;<strong>Android 应用层</strong>：包括系统应用和第三方应用等等，其中Android会同一系列核心应用程序包一起打包发布，其应用程序包括短信，联系人，日历，等等。</p><p>&emsp;&emsp;<strong>Android 应用框架层</strong>:可以说是应用程序的核心，所有的应用开发都必要遵循其框架的原则。同时，通过该框架，我们完全可以访问其核心应用程序所使用的API框架。(需要服从框架执行的安全限制)。当然，我们也可以在通过继承在其框架上进行扩展，以实现个性化应用等。【引用和了解的博客:<a href="https://www.cnblogs.com/chrisbosh/p/5372990.html">软件体系结构—安卓系统架构之应用程序框架层分析—1</a>】</p><p>&emsp;&emsp;包含 <strong>Activity Manager(活动管理器)、Window Manager(窗口管理器)、Content Provider(内容提供器)、 View System(视图系统)、 Notification Manager(通告管理器)、Package Manager(包管理器)、 Telephony Manager(电话管理器)、  Location Manager、Resource Manager(位置管理器)、XMPP Service(XMPP服务)</strong>。</p><table><thead><tr><th align="center">系统&#x2F;服务</th><th align="center">英文名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">活动管理器</td><td align="center">Activity Manager</td><td align="center">管理各个应用的生命周期以及导航回退功能等。</td></tr><tr><td align="center">窗口管理器</td><td align="center">Window Manager</td><td align="center">窗口主要分为两种窗口:应用窗口和公共窗口。其中应用窗口是指应用中的窗口，例如主界面，Dialog弹窗,菜单等等。而公共窗口则大部分值系统级别的，例如下拉状态栏，锁屏界面等。</td></tr><tr><td align="center">内容提供器</td><td align="center">Content Provider</td><td align="center">内容提供者是应用程序之间共享数据的一直接口机制，能够使得不同的程序之间存取和分享数据。</td></tr><tr><td align="center">视图系统</td><td align="center">View System</td><td align="center">其构成了应用程序的基本组件。例如文本框，按钮等。</td></tr><tr><td align="center">通告管理器</td><td align="center">Notification Manager</td><td align="center">使得应用程序可以在状态栏上显示自定义的提示信息。</td></tr><tr><td align="center">包管理器</td><td align="center">Package Manager</td><td align="center">系统中对于程序的管理。</td></tr><tr><td align="center">电话管理器</td><td align="center">Telephony Manager</td><td align="center">用于管理手机的通话状态，电话信息以及电话通讯等</td></tr><tr><td align="center">资源管理器</td><td align="center">Resource Manager</td><td align="center">其用于提供应用程序中的各种非代码资源。注意：资源管理器提供的是应用程序中的资源，而不是外部存储的资源</td></tr><tr><td align="center">位置管理器</td><td align="center">Location Manager</td><td align="center">顾名思义，其负责和管理位置信息</td></tr><tr><td align="center">XMPP服务</td><td align="center">XMPP Service</td><td align="center">用于提供一些服务。XMPP（Extensible Messageing and Presence Protocol：可扩展消息与存在协议）：是一种即时消息协议，其用与信息的传输。</td></tr></tbody></table><p>&emsp;&emsp;<strong>Android 系统运行层</strong>：其通过一些C&#x2F;C++库来为Android提供主要的特性支持。其包括两部分，一部分是系统库，另外一部分则是Android NDK。NDK这里不做解释了，在<a href="https://lqzhi.github.io/2020/02/16/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/">安卓开发 开发前你需要了解的一些资料(一)</a>已经了解过了。我们这里解释一下系统库。【引用和了解来自与<a href="https://baike.baidu.com/item/Android%E7%B3%BB%E7%BB%9F%E6%9E%84%E6%9E%B6/15591610?fr=aladdin">百度百科-Android系统构架</a>】</p><p>&emsp;&emsp;系统库:<strong>Libc、Media Framework、Surface Manager、Webkit、SGL、SSL、OpenGL ES、greeType、SQLite。</strong></p><table><thead><tr><th align="center">库名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Libc</td><td align="center">系统C库,一个从BSD继承来的标准C系统函数库,专门为基于Embedded linux的设备定制的。</td></tr><tr><td align="center">Media Framework</td><td align="center">多媒体库,基于PacketVideoopencore;该库支持多种常用的音频、视频格式回放和录制，同时支持静态图像文件。编码格式包括MPEG4,H.264,MP3,AAC,AMR,JPG,PNG。</td></tr><tr><td align="center">Surface Manager</td><td align="center">负责管理针对显示子系统的访问，并且为多个应用程序提供了2D和3D图层的无缝融合。</td></tr><tr><td align="center">Webkit</td><td align="center">浏览器引擎,支持Android浏览器和一个可嵌入的web视图</td></tr><tr><td align="center">SGL</td><td align="center">底层的2D图形引擎</td></tr><tr><td align="center">SSL</td><td align="center">位于TCP&#x2F;IP协议栈与各种应用层协议之间，为数据通信提供支持</td></tr><tr><td align="center">OpenGL ES</td><td align="center">用于对3D效果的支持,基于OpenGLES 1.0 APIs实现;该库可以使用硬件3D加速或者使用高度优化的3D软加速。</td></tr><tr><td align="center">greeType</td><td align="center">位图(bitmap)和<a href="https://baike.baidu.com/item/%E7%9F%A2%E9%87%8F/12795520">矢量</a>(vector)字体显示</td></tr><tr><td align="center">SQLite</td><td align="center">一个对于所有应用程序可用，功能强劲的轻型关系型数据库引擎。(安卓内置的数据库)</td></tr></tbody></table><p><strong>（安卓在运行时，其运行了核心库，同时也运行着Dalvik虚拟机(应用运行在Dalvik虚拟机上)，Dalvik虚拟机不同于Java虚拟机,在安卓中，每一个应用程序都运行在自己的进程上,其由Dalvik虚拟机分配。Dalvik虚拟机是一种基于寄存器的Java虚拟机,可执行的文件格式为.dex 。Dalvik做了大量的内存优化，其在一些底层方面,Dalvik虚拟机需要依赖Linux内核。）</strong><br>&emsp;&emsp;<strong>Linux 内核层</strong>:整个安卓系统框架的最底层，其为Android设备各种硬件提供了驱动。同时其也为硬件与软件打通了联系。这里不过多解释。所以说安卓是基于Linux的，因为其底层为Linux。</p><blockquote><p>安卓四大核心组件:Activity+Service+BroadcastReceiver+ContentProvider</p></blockquote><p>&emsp;&emsp;我们了解安卓的系统框架之后，当我们在开发安卓应用时，我们要了解到其组成。<strong>Android的应用程序通常是由一个或多个基本组件组成</strong>(不同与其他语言，安卓中并没有常见的应用程序入口，例如C\C++、Java中的main方法)，组件可以是被调用的基本功能模块。安卓程序利用组件实现程序内部或程序之间的模块调用来解决代码复用的问题，这也是Android程序非常重要的特性。</p><p>&emsp;&emsp;安卓程序中有4大核心组件：<strong>Activity(活动)、Service(服务)、BroadcastReceiver(广播接收者)、ContentProvider(内容提供者)。</strong></p><h5 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h5><p>&emsp;&emsp;Activity 是安卓中最基本的模块，其为用户操作提供一个可视化界面，在一个安卓程序中，可以包含一个或多个Activity。</p><p>Activity 是由 Android 系统进行维护的，它有自己的生命周期。其后面再了解。</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>&emsp;&emsp;Service是服务意思，其没有可视化的用户界面，主要是在后台运行，其可以在后台运行很久很久，甚至当App关闭掉时，Service依旧可以运行。例如：用户在做其它事情时可以在后台播放歌曲，在下载视频时可以切换致其它App，依旧可以下载。这就是服务的强大之处。<strong>(注意:服务不是线程.其运行在主线程中。需要注意)</strong></p><h5 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h5><p>&emsp;&emsp;BroadcastReceiver(广播接收者)是一个专注于接收广播通知消息，并对其做出相对应的出来的组件。在安卓系统中，有着许许多多的广播，例如系统开机，系统将会发送一条广播,电量过低，系统也就会发送一条广播，网络改变，电量变化等等。当然自己的程序也可以发送广播。一个Android应用可以拥有任意数量的广播接收器，以对所有它感兴趣的通知信息予以响应。<strong>BroadcastReceiver是没有UI(图形界面)的,我们通常需要NotificationManager来通知用户。</strong></p><h5 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h5><p>&emsp;&emsp;ContentProvider(内容提供者) 是 应用程序之间共享数据的一种接口机制，它是一种更为高级的数据共享方法，可以指定需要共享的数据，而其他应用程序则可以在不知道数据来源、路径的情况下，对共享数据进行操作。</p><blockquote><p>AndroidManifest.xml</p></blockquote><p>&emsp;&emsp;每一个Android 模块都必须包含一个清单（Manifest）文件 AndroidManifest.xml。在<a href="https://lqzhi.github.io/2020/02/16/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/">安卓开发 开发前你需要了解的一些资料(一)</a>已经说明了一些常用的标签。为什么我们又要在这里提及呢？因为<strong>当我们创建一个活动(Activity)、服务(Service)、内容提供者(ContentProvider)都  必须 必须 必须  需要在清单文件中声明！而广播接受者(BroadcastReceiver)既可以在清单文件中声明静态注册,也可以在代码中进行动态注册。</strong></p><blockquote><p>组件大小单位</p></blockquote><p>&emsp;&emsp;在Android中UI组件其像素单位有：<strong>px</strong>(像素)，<strong>in</strong>(英寸)，<strong>mm</strong>(毫米)，<strong>pt</strong>(磅，1&#x2F;72英寸)，<strong>dp</strong>(与设备无关的显示单位)，<strong>dip</strong>(就是dp)，<strong>sp</strong>(用于设置字体大小)。其中，常用的有<strong>px、dp、sp</strong>。下面简单介绍一下。</p><p>&emsp;&emsp;在众多的单位中,<strong>px</strong>是可显示的最小的单位,其<strong>1dp</strong>就代表一个像素，其与物理设备的显示屏有关。</p><p>&emsp;&emsp;<strong>dp</strong>是一种与设备无关的显示单位，其只与屏幕的尺寸有关。</p><p>​        <strong>sp</strong>与<strong>dp</strong>原理是一样的，<strong>当手机系统设置的字体大小为普通字体大小时，sp和dp是一样的。而当字体大小设置为大字体时，sp所显示的大小将会比dp大。</strong></p><p><strong>当我们在设计UI时，最好除了文字大小使用sp单位，其他都使用dp单位。</strong></p><p><strong>另外，我们需要注意的是，在xml布局文件中，当我们使用dp为单位时，我们如果要在代码中修改大小，我们需要转换一下，因为          Android中用于设置大小的函数都以px为单位。所以我们得将dp值换为px值。</strong></p><p><strong>px,sp,dp互相转换的推荐博客:</strong><a href="https://blog.csdn.net/zxl1173558248/article/details/81182041">px,sp,dp相互转换</a></p><blockquote><p>颜色</p></blockquote><p>&emsp;&emsp;在Android中，颜色值都是由透明度alpha和RGB(红、绿、蓝)三原色所定义的，有<strong>八位</strong>十六进制数和<strong>六位</strong>十六进制数两种编码。例如八位编码FFEEDDCC，FF表示透明度,EE表示红色的浓度，DD表示绿色的浓度，CC表示蓝色的浓度。而六位十六进制数则自动省略了最开头的两位(表示透明度的)。<strong>需要注意的是：在XML文件中默认是不透明的，而在代码中，默认是透明的。</strong></p><p>&emsp;&emsp;在安卓系统中，已定义12种颜色任开发者选择。其具体的类型定义在<strong>Color</strong>类中。可以直接在代码中调用，而在<strong>xml</strong>文件中,颜色种类更多,使用<code>&quot;@android:color/颜色名&quot;</code></p><table><thead><tr><th align="center">Color类中颜色</th><th align="center">说明</th><th align="center">Color类中颜色</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Color.BLACK</td><td align="center">黑色</td><td align="center">Color.WHITE</td><td align="center">白色</td></tr><tr><td align="center">Color.GREEN</td><td align="center">绿色</td><td align="center">Color.RED</td><td align="center">红色</td></tr><tr><td align="center">Color.GRAY</td><td align="center">灰色</td><td align="center">Color.YELLOW</td><td align="center">黄色</td></tr><tr><td align="center">Color.BLUE</td><td align="center">蓝色</td><td align="center">Color.DKGRAY</td><td align="center">深灰色</td></tr><tr><td align="center">Color.MAGENTA</td><td align="center">玫瑰红</td><td align="center">Color.TRANSPARENT</td><td align="center">透明</td></tr></tbody></table><p>&emsp;&emsp;Color类颜色：</p><p><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/1.webp" alt="颜色类.png"></p><blockquote><p>XML文件</p></blockquote><p>&emsp;&emsp;在前面中，我们多次提到xml。为了防止个别不懂，所以这里简单介绍一下。<strong>XML指可扩展标记语言，被设计用于传输和存储数据。其结构大致上类似于HTML的标签一样，由 尖括号 包围关键字,例如<acitvity />，其具有一个开始标签和一个结束标签（必须包含结束标签)，其中 被开始标签和结束标签所包围的数据就是属于该标签的数据。</strong></p><p>​        <strong>例如：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--这是一个用户信息--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-comment">&lt;!--根标签--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Chinese&quot;</span>&gt;</span>露西<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-comment">&lt;!--姓名标签，其中type是姓名标签的属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span><span class="hljs-comment">&lt;!--性别标签--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>16<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><span class="hljs-comment">&lt;!--年龄标签--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">remark</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Chinese&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!--备足标签,注意这里使用了结束标签另外一种形式--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><span class="hljs-comment">&lt;!--user根标签的结束标签--&gt;</span><br><span class="hljs-comment">&lt;!--这是一个注释--&gt;</span><br></code></pre></td></tr></table></figure><p>​        <strong>XML的一些语法</strong></p><ol><li><p><strong>所以的XML标签都必须要关闭标签</strong></p></li><li><p><strong>开始标签和结束标签对大小写敏感，必须一致！</strong></p></li><li><p><strong>标签中嵌套其它元素必须要正确的嵌套，错误示范：<user><name> 刘某某 <user><name> 。</strong></p></li><li><p><strong>XML文档必须要具有根标签，也就是说，必要要有一个元素是所有元素的父元素。错误示范：<name></name><sex></sex> (存在了两个根标签：name和sex。必须使用一个标签包裹他们才行。)</strong></p></li><li><p><strong>XML中的属性值必须加引号进去区分：错误示范 <name type=Chinese />(错误,type属性的值没有加引号)</strong></p></li><li><p><strong>在XML中，某些字符具有特殊意义，例如<code>&lt;</code>。其无法判断是开始标签还是值，所以当我们在使用<code>&lt;</code>作为值时，需要使用<code>&amp;lt;</code>代替。在XML中，有5个预定义的实体引用：</strong></p><table><thead><tr><th align="center">引用</th><th align="center">符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>&amp;lt;</code></td><td align="center"><strong>&lt;</strong></td><td align="center"><strong>小于</strong></td></tr><tr><td align="center"><code>&amp;gt;</code></td><td align="center"><strong>&gt;</strong></td><td align="center"><strong>大于</strong></td></tr><tr><td align="center"><code>&amp;amp;</code></td><td align="center"><strong>&amp;</strong></td><td align="center"><strong>和号</strong></td></tr><tr><td align="center"><code>&amp;apos;</code></td><td align="center">’</td><td align="center"><strong>单引号</strong></td></tr><tr><td align="center"><code>&amp;quot;</code></td><td align="center">”</td><td align="center"><strong>双引号</strong></td></tr></tbody></table></li><li><p><strong>在XML中，空格也会保留。</strong></p></li></ol><blockquote><p>编写安卓的Hello World(不使用模板)</p></blockquote><p>&emsp;&emsp;&#x3D;-&#x3D;简书里面不能放视频 ？！！！！！哎，算了。还是使用截图吧。<br>第一步：新建一个项目<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/2.webp" alt="新建一个项目1"><br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/3.webp" alt="loading-ag-1524"></p><p>第二步：不选择模板<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/4.webp" alt="不选择模板"><br>第三步：添加项目名以及包名等信息(我选择的是Java，根据自己情况填写)</p><p><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/5.webp" alt="添加项目名以及包名等信息">第四步：等待同步完成</p><p><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/6.webp" alt="等待同步完成">第五步：在项目开发资源文件中创建Acitvity布局文件<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/7.webp" alt="loading-ag-1557"></p><p>或者自己在<strong>res</strong>目录中创建<strong>layout</strong>文件夹。然后再创建一个xml文件。然后在包中创造活动的实体类。也是一样的。(偷一下懒,这个重点不是在这。)</p><p><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/8.webp" alt="配置我们的活动"></p><p>下面是一些注释。注意。</p><p><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/9.webp" alt="活动实体类"></p><p><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/10.webp" alt="布局"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;30sp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#FF000000&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintTop_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_constraintBottom_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;MissingConstraints&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第六步(最最重要的一步！！):配置AndroidManifest.xml清单文件。<br>&emsp;&emsp;<strong>需要在清单文件中，指明该活动实体类为App启动时启动的活动！不然无法启动！</strong><br><br>&emsp;&emsp;<strong>其中最重要的就是在意图过滤中，指明该活动实体类为App启动时的。就是在意图过滤中指明：<code>&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</code>，<code>&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</code></strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.palz.learn&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/app_name&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:roundIcon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/AppTheme&quot;</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--活动元素--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--指明活动实体类--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><span class="hljs-comment">&lt;!--意图过滤节点 ：只有符合该元素的才能启动活动--&gt;</span><br>                <span class="hljs-comment">&lt;!--指明在App启动时，启动该活动--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第七步：运行即可<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%BA%8C/11.webp" alt="loading-ag-1580"></p><blockquote><p>后话</p></blockquote><p>安卓的应用程序由各个组件组成。其中安卓的四大核心组件是我们必须所掌握的。<br>而在编写第一个Hello World时，推荐自己去配置清单文件。再多说一句：<strong>当我们创建一个活动(Activity)、服务(Service)、内容提供者(ContentProvider)都  必须 必须 必须  需要在清单文件中声明！而广播接受者(BroadcastReceiver)既可以在清单文件中声明静态注册,也可以在代码中进行动态注册。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发 开发前你需要了解的一些资料(一)</title>
    <link href="/2020/02/16/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/"/>
    <url>/2020/02/16/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>&emsp;&emsp;在<a href="https://www.jianshu.com/p/0cc5ea986997">安卓开发 初步了解安卓和配置安卓环境</a>中，我们简单的介绍了安卓和配置安卓环境。我们使用了Android Studio作为我们开发安卓的主要工具。所以，在本次中依旧使用Android Stuido。</p><blockquote><p>了解 JDK、SDK、NDK</p></blockquote><p><strong>JDK</strong><br>&emsp;&emsp;JDK是JAVA语言的编译器，全称为Java Development Kit,即Java开发工具包。因为Android应用层采用Java开发，其运行在Java虚拟机(Dalvik虚拟机,与JVM虚拟机不同)上。关于JDK如何安装请看了解<a href="https://www.jianshu.com/p/3307dcf1a8e5">记录三 JAVA环境安装(1.8示例)</a>。<br>&emsp;&emsp;<strong>JDK建议安装1.8及其以上版本</strong>，因为不同的Android版本对JDK有相应的要求，例如Android 5.0默认使用JDK1.7编译，Android 7.0默认使用JDK1.8编译。<br>&emsp;&emsp;如果JDK为1.6或者1.78，而SDK为最新版本，就可能会导致一下问题。<br>&emsp;（1）创建项目后，浏览布局文件设计图时会报错Android N requires the IDE to be running with Java 1.8 or later.<br>&emsp;&emsp;（2）编译项目失败，提示错误 com&#x2F;android&#x2F;dx&#x2F;command&#x2F;dexer&#x2F;Main: Unsupported major.minor version 52.0.<br>&emsp;&emsp;（3）运行App失败，提示错误complieSdkVersion ‘android-24’ requires JDK 1.8 or later to compile.<br>SDK<br>&emsp;&emsp;SDK是Android应用的编译器，全称为 Software Development Kit，即软件开发工具包。SDK提供了App开发的常用工具合集。<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/1.webp" alt="loading-ag-673"></p><p> 其中主要包括:</p><ul><li><p>add-ones 目录: 存放Google提供的服务扩展包。(Eclipse存在,Android Studio已经移动到其它地方去了。)</p></li><li><p>build-tools 目录: 存放各版本Android的各种编译工具。</p></li><li><p>docs 目录: 存放开发说明文档。</p></li><li><p>extras目录: 存放Android附加支持文件。主要有Android 的 support 支持包，Google 的几个工具和驱动、Intel 的 IntelHaxm。</p></li><li><p>platforms 目录: 存放各个版本的Android资源文件。包括字体、res 资源、模板等。</p></li><li><p>platform-tools和tools 目录，存放常用的开发辅助工具。十分重要。</p></li><li><p>samples 目录:存放各版本Android常用功能的demo 源码。</p></li><li><p>sources 目录: 存放各版本Android的API开发接口源码。</p></li><li><p>system-images 目录:存放模拟器各版本的系统镜像与管理工具。</p></li><li><p>emulator 目录: 存放模拟器软件。</p></li><li><p>patcher：存放补丁文件夹。(我也不知道是啥，翻译过来就是补丁)</p></li><li><p>cmake：存放跨平台的编译工具，用来编译C&#x2F;C++代码。</p></li><li><p>ndk : 存放NDK开发工具。</p></li><li><p>fonts：存放字体。</p></li><li><p>licenses：存放SDK的验证，文件中存放着SKD的校验码。</p></li><li><p>lldb：存放c&#x2F;c++调试器，用于NDK的调试。</p></li><li><p>skins：皮肤文件夹，存放一些虚拟机的效果图片。<br>(注：图片中仅仅是刚安装上的SDK。后面下载会会新添一些文件。例如安装了NDK的话就会存在ndk文件夹。)<br><strong>NDK</strong><br>&emsp;&emsp;&emsp;NDK是C\C++代码的编译器,全称Native Development Kit。即原生开发工具包。该工具主要提供JNI接口使用，先将C\C++代码编译成so库,然后由Java代码通过JNI接口调用so库。<br>&emsp;&emsp;因为Java字节码极其容易反编译查看到源代码，所以利用C\C++编译出来的so库可以存放一些核心代码，so库与Java字节码更难破解。且C\C++运行速度比Java快，可以编写一些处理量比较大、耗时的数据。(例如，音频，视频的处理运算。)</p><blockquote><p>简单了解Gradle</p></blockquote></li></ul><p>&emsp;&emsp;Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置。其主要用于描述Android开发所需要的环境，管理第三方jar包，第三方扩展库，jar依赖关系等。</p><blockquote><p>了解开发App的工程结构</p></blockquote><p>&emsp;&emsp;Android Studio的工程创建分成了两个层次。<br>第一层次是<strong>Project</strong>(项目)，指定了当前项目的工作空间。其相当于Eclipse的workspace。<br>第二层次是<strong>Module</strong>(模块)，指定了当前项目中的模块，其中一个模块指一个单独的App工程。但也可以通过模块化编程合为一个App。其相当于Eclipse的project。<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/2.webp" alt="Project结构图"><br>&emsp;&emsp;从结构构图中可以看到，该项目下有4个文件夹，其中<code>.gradle</code>用来保存gradle的依赖信息,<code>.idea</code>用来保存开发工具的设置信息。而<code>app</code>是我们主要开发的文件夹，gradle是存放gradle的文件。我们只要关心app文件夹即可。<br>  不过呢，还是要需要了解一些其根目录下的一些文件。</p><ul><li><p>.gitignore 文件：指明git忽略文件清单，其指定的文件夹不会上传到仓库中。</p></li><li><p>Account.iml 文件:是项目用于保存开发工具信息的文件。其文件名是项目名。</p></li><li><p>build.gradle 文件:项目级编译规则文件，用于描述整个项目工程的编译规则。</p></li><li><p>proguard-rules.pro 文件:用于描述Java文件的代码混淆规则。</p></li><li><p>gradle.properties 文件:用于配置编译工程的命令行参数，一般无需改动。</p></li><li><p>gradlew 文件: Gradle Wrapper，用于是Gradle本身的安装、部署。其为Linux 下可执行脚本。</p></li><li><p>gradlew.bat 文件: Gradle Wrapper，用于是Gradle本身的安装、部署。其为Windows下可执行脚本。</p></li><li><p>local.properties 文件: 用于描述开发者本机的环境配置。SDK、NDK等指定路径就该文件中。</p></li><li><p>settings.gradle 文件：配置哪些模块一起编译。初始内容为include ‘:app’，表示只编译App模块。</p></li></ul><p>&emsp;&emsp;其实app文件夹就是一个Module。当我们在创建一个新的Project时，就创建了一个默认的Module。其就是app文件夹。<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/3.webp" alt="loading-ag-695"></p><p>其中主要包括：</p><ul><li>build 目录:存放编译构建后的文件。</li><li>libs 目录:存放第三方jar包。</li><li>src 目录:源文件。</li><li>build.gradle 文件：当前Module的配置文件。</li></ul><p>其中src目录和build.gradle文件比较重要。下面会仔细讲解。<br>&emsp;&emsp;<strong>src文件夹包含了androidTest文件夹、main文件夹(重要！)、test文件夹。</strong></p><ul><li>androidTest 目录:安卓单元测试。其主要涉及Android仪器的单元测试。</li><li>main 目录:开发目录。</li><li>test 目录:单元测试。其不包含安卓的框架测试。</li></ul><p>其中androidTest和test主要包含了java目录，其中包含着相对应的测试。而main是我们主要的开发目录。主要包括如下：</p><ul><li><p>java 目录：主要存放java文件。其目录下是包名。</p></li><li><p>res 目录: 安卓资源文件夹。主要存放布局资源，图片资源等等。</p></li><li><p>res\drawable 目录: 存放图形描述文件与用户图片。其中后面跟随着的hdpi、mdpi、xhdpi、xxhdpi等等都是指图片的分辨率，相对应的图片应该放入相对应的文件夹中。</p></li><li><p>res\mipmap 目录:app的图标文件夹。存放app的图标。其同drawable文件夹一样，都有着相对应的分辨率文件夹。</p></li><li><p>res\layout 目录:存放app页面的布局文件。</p></li><li><p>res\values 目录:存放的是一些常量定义文件。例如字符串常量定义string.xml,像素常量dimens.xml、颜色常量colors.xml，样式风格styles.xml等。</p></li><li><p>AndroidManifest.xml 文件:安卓清单文件。(<strong>重要！指定其内部的运行配置！</strong>)</p></li></ul><p><strong>AndroidManifest.xml部分说明：</strong><br>&emsp;&emsp;AndroidManifest.xml 用于指定App内部的运行配置,其是一个XML描述文件，根节点为manifest，根节点的package 指定了该App的包名。manifest下面又有若干个子节点,分别说明如下。<br>(一份当前我制作app的AndroidManifest.xml文件内容)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-comment">&lt;!--说明xml文件的版本和编码格式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:dist</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/distribution&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.palz.account&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--根节点,指定app的包名--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dist:module</span> <span class="hljs-attr">dist:instant</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!--模块化结点,指定Goolge Play免安装--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--应用根结点--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span> </span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        &lt;!<span class="hljs-attr">--允许备份--</span>&gt;</span><br>        android:allowBackup=&quot;true&quot;<br><br>        <span class="hljs-comment">&lt;!--指定app的启动图标--&gt;</span><br>        android:icon=&quot;@mipmap/ic_launcher&quot;<br><br>        <span class="hljs-comment">&lt;!--指定app的名称--&gt;</span><br>        android:label=&quot;@string/app_name&quot;<br><br>        <span class="hljs-comment">&lt;!--指定app的圆形图标--&gt;</span><br>        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;<br><br>        <span class="hljs-comment">&lt;!--是否愿意支持从右到左(RTL是right-to-left 的缩写)的布局--&gt;</span><br>        android:supportsRtl=&quot;true&quot;<br><br>        <span class="hljs-comment">&lt;!--指定app的主题--&gt;</span><br>        android:theme=&quot;@style/AppTheme&quot;&gt;<br><br>        <span class="hljs-comment">&lt;!--活动根结点--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--Intent过滤器根结点:只有符合相对应的要求才能通过Intent启动活动--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中， AndroidManifest.xml 能够包含的节点有:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dist:module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dist:delivery</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dist:install-time</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dist:conditions</span>&gt;</span><br>              <span class="hljs-comment">&lt;!-- Requires that the device support AR to download the module at</span><br><span class="hljs-comment">              app install-time.  --&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">dist:device-feature</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dist:conditions</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dist:install-time</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dist:delivery</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dist:module</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">permission</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">permission-tree</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">permission-group</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">instrumentation</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-sdk</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-configuration</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-feature</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">supports-screens</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">compatible-screens</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">supports-gl-texture</span> /&gt;</span> <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">data</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activity-alias</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>. . .<span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activity-alias</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>. . .<span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">receiver</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>. . .<span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">provider</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">grant-uri-permission</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">path-permission</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">uses-library</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面介绍几个常用的标签节点</p><ol><li>manifest 标签:<br>&emsp;&emsp;manifest标签是AndroidManifest.xml 的根节点标签。其常用于设置与项目相关的一些属性。例如比如用于唯一标识应用程序的 package 属性，用于记录应用程序版本的 Android:versionName 属性等等。<br>&emsp;&emsp;其中xmls:android属性必须为<code>http://schemas.android.com/apk/res/android</code>,<br>&emsp;&emsp;xmlns:dist属性必须为<code>http://schemas.android.com/apk/distribution</code>。<br>其用于表示命名空间。</li><li>application 标签:<br>&emsp;&emsp; manifest 标签中有且只有一个 application 标签。其用于指定应用程序的各种元数据（包括标题、图标和主题）。同时也可以作为活动(Activity),服务(Service),内容提供器（Provider）和广播接收器（Broadcast Receiver）标签的容器,用于指示应用程序组件。</li><li>uses-permission 标签:<br>&emsp;&emsp;uses-permission标签用于指明程序会使用到的权限。而这些权限是应用正常运行所必须的。。</li><li>permission 标签:<br>&emsp;&emsp;permission 标签用于指明其它程序访问你的组件时所需要的权限，当你提供了其它功能给其它软件时，其它软件需要在清单文件(AndroidManifest.xml)中指明其permission才可以访问到你的组件功能或者数据。<br>5.instrumentation 标签：<br>&emsp;&emsp;istrumentation 标签其指明了instrumentation 类的测试类。instrumentation 类提供一个框架，用来在应用程序运行时在活动或者服务上运行测试，可以通过它来监控应用程序及其与系统资源的交互。每当应用程序新添一个测试类时，需要为其新添一个节点。</li></ol><p>app中所包含的目录介绍到这里。下面介绍一下啊app根目录下的几个文件:</p><ul><li><p>build.gradle 文件：该文件用于App工程的编译规则。</p></li><li><p>.gitignore 文件: 该文件用于指明git忽略清单，其包含的文件不会上传到仓库中。</p></li><li><p>gradle.properties 文件：该文件用于配置编译工程的命令行参数，一般无需改动。</p></li><li><p>app.iml 文件:用来保存开发工具信息。该文件名是当前模块名。</p></li></ul><p>其中最为重要的是build.gradle。下面简单的介绍一下build.gradle文件：<br>&emsp;&emsp;build.gradle分为项目级别和模块级别，项目级别的我们一般无需改动，我们只需要关注模块级别的build.gradle即可。<br>(一份当前我在制作app的build.gradle的文件(app模块))</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><span class="hljs-comment">//指明module的类型，com.android.application为程序，com.android.library为安卓库</span><br><br>android &#123;<br>    compileSdkVersion <span class="hljs-number">29</span><span class="hljs-comment">//编译的SDK版本</span><br>    buildToolsVersion <span class="hljs-string">&quot;29.0.3&quot;</span><span class="hljs-comment">//编译的Tools版本</span><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&quot;com.palz.account&quot;</span><span class="hljs-comment">//应用程序的包名</span><br>        minSdkVersion <span class="hljs-number">15</span> <span class="hljs-comment">//最低支持的目标版本</span><br>        targetSdkVersion <span class="hljs-number">29</span><span class="hljs-comment">//当前最高支持的目标版本</span><br>        versionCode <span class="hljs-number">1</span> <span class="hljs-comment">//版本号</span><br>        versionName <span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-comment">//版本名</span><br>        testInstrumentationRunner <span class="hljs-string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><span class="hljs-comment">//安卓测试库</span><br>    &#125;<br>    buildTypes &#123;<span class="hljs-comment">//build类型</span><br>        release &#123;<span class="hljs-comment">//发布</span><br>            minifyEnabled <span class="hljs-literal">false</span> <span class="hljs-comment">//是否开启混淆代码功能</span><br>            <span class="hljs-comment">//指定代码混淆规则文件的文件名</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>dependencies &#123;<span class="hljs-comment">//指定App的编译信息</span><br>    implementation fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<span class="hljs-comment">//指定引用jar包的路径</span><br>    implementation <span class="hljs-string">&#x27;androidx.appcompat:appcompat:1.1.0&#x27;</span><span class="hljs-comment">//引用appcompat库</span><br>    implementation <span class="hljs-string">&#x27;androidx.constraintlayout:constraintlayout:1.1.3&#x27;</span><span class="hljs-comment">//引用constrainlayout库</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.12&#x27;</span><span class="hljs-comment">//指定单元测试编译用的版本号</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.ext:junit:1.1.1&#x27;</span><span class="hljs-comment">//指定安卓测试编译用的版本号</span><br>    androidTestImplementation <span class="hljs-string">&#x27;androidx.test.espresso:espresso-core:3.2.0&#x27;</span><span class="hljs-comment">//使用Espresso的进行测试的版本号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还有许多配置没有写出来。这里只是简单的了解一下，有需要的可以参考以下博客或者自行必应搜索。</p><h5 id="build-gradle文件的注释"><a href="#build-gradle文件的注释" class="headerlink" title="build.gradle文件的注释"></a><a href="https://www.cnblogs.com/zhangmiao14/p/6888143.html">build.gradle文件的注释</a></h5><p>App的工程结构了解到此结束。</p><blockquote><p> Android Studio的部分使用方法</p></blockquote><p>&emsp;&amp;&amp;emspAndroid Studio是基于IDEA开发的，其大部分使用其实是和IDEA是差不多的。下面大致介绍一下Android Studio的框图。<br><img src="/img/docs/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%89%8D%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99-%E4%B8%80/4.webp" alt="loading-ag-714"><br>还有一些常用的快捷键:</p><ul><li>Ctrl+S : 保存文件</li><li>Ctrl+Z ：撤销上次操作</li><li>Ctrl+Shift+Z : 重做上一次编辑。</li><li>Ctrl+Y：删除当前行</li><li>Ctrl+C：复制</li><li>Ctrl+X：剪切</li><li>Ctrl+V：粘贴</li><li>Ctrl+A：全选</li><li>Delete：删除</li><li>Ctrl+F：查询</li><li>Ctrl+R：替换</li><li>Ctrl+&#x2F;：注释选中的代码(采用&#x2F;&#x2F;注释)</li><li>Ctrl+Shift+&#x2F;：注释选中的代码(采用&#x2F;**&#x2F;注释)</li><li>Shift+F6：重命名</li><li>Alt+Enter：给光标所在位置的类导入相应的包(推荐设置自动导入包)</li><li>Shift+F10：运行当前模块</li><li>Ctrl+F5:清理并重新运行当前模块</li></ul><p>以及一些常用的插件：</p><ol><li><p><a href="http://plugins.jetbrains.com/plugin/7595?pr=androidstudio">Android Code Generator</a>：根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu类。</p></li><li><p><a href="http://plugins.jetbrains.com/plugin/7275?pr=androidstudio">CodeGlance</a>：右边快速预览代码，实现快速定位。</p></li><li><p><a href="https://github.com/Skykai521/ECTranslation">ECTranslation</a>：翻译软件。</p></li></ol><p>还有更多以及更常用的插件可以查看博客:<a href="https://www.cnblogs.com/Awangzhen/p/8906335.html">Android Studio实用插件集合</a>。在此不再列出。(&#x3D;-&#x3D;主要是自己只使用了这三个。)</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初步了解安卓和配置安卓环境</title>
    <link href="/2020/02/14/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/02/14/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>安卓(Android)</p></blockquote><p>&emsp;&emsp;Android是一个开源的，基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑。</p><blockquote><p>安卓发展史</p></blockquote><p>&emsp;&emsp;Android的本意是指”机器人”,标志也是一个机器人。它是Google公司专门为了移动设备开发的平台，其中包含了操作系统、中间件和核心应用等。<br>&emsp;&emsp;Android最早由Andy Rubin创办、于2005年被Google收购。<br>&emsp;&emsp;2007年11月5日，Google与84家硬件制造商、软件开发商及电信营运商组建开放手机联盟共同研发改良Android系统。随后Google以Apache开源许可证的授权方式，发布Android的源代码。<br>&emsp;2010年底  Android超越称霸10年的诺基亚Symbian系统，成为全球最受欢迎的智能手机平台。<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/1.webp" alt="安卓机器人"><br>&emsp;&emsp;在Android的发展过程中，已经经历了十多个主要版本的变化，每个版本的代号都是以甜点来命名。该命名方法开始于Android 1.5版本，并按照首字母顺序进行发布。到目前(2020年2月14日)时间为止，目前Android迄今发布的主要版本以及其发布时间以及唯一标识 API 框架版本。</p><table><thead><tr><th align="center">版本号</th><th align="center">别名</th><th align="center">发布时间</th><th align="center">API 等级</th></tr></thead><tbody><tr><td align="center">1.0</td><td align="center">无</td><td align="center">2008年9月22日</td><td align="center">1</td></tr><tr><td align="center">1.1</td><td align="center">Petit Four(纸杯小蛋糕)</td><td align="center">2009年2月2日</td><td align="center">2</td></tr><tr><td align="center">1.5</td><td align="center">Cupcake(纸杯蛋糕)</td><td align="center">2009年4月30日</td><td align="center">3</td></tr><tr><td align="center">1.6</td><td align="center">Donut(甜甜圈)</td><td align="center">2009年9月15日</td><td align="center">4</td></tr><tr><td align="center">2.0</td><td align="center">Éclair(闪电泡芙)</td><td align="center">2019年10月26日</td><td align="center">5</td></tr><tr><td align="center">2.0.1</td><td align="center">Éclair(闪电泡芙)</td><td align="center">2009 年 12 月 3 日</td><td align="center">6</td></tr><tr><td align="center">2.1.x</td><td align="center">Éclair(闪电泡芙)</td><td align="center">2010 年 1 月 10 日</td><td align="center">7</td></tr><tr><td align="center">2.2</td><td align="center">Froyo(冻酸奶)</td><td align="center">2010年5月20日</td><td align="center">8</td></tr><tr><td align="center">2.3~2.3.2</td><td align="center">Gingerbread(姜饼)</td><td align="center">2010年12月7日~2011年1月</td><td align="center">9</td></tr><tr><td align="center">2.3.3~2.3.7</td><td align="center">Gingerbread(姜饼)</td><td align="center">2011年2月9日~未知</td><td align="center">10</td></tr><tr><td align="center">3.0</td><td align="center">Honeycomb(蜂巢)</td><td align="center">2011年2月2日</td><td align="center">11</td></tr><tr><td align="center">3.1</td><td align="center">Honeycomb(蜂巢)</td><td align="center">2011年5月10日</td><td align="center">12</td></tr><tr><td align="center">3.2</td><td align="center">Honeycomb(蜂巢)</td><td align="center">2011年7月15日</td><td align="center">13</td></tr><tr><td align="center">4.0~4.0.2</td><td align="center">Ice Cream Sandwich(冰淇淋三明治)</td><td align="center">2011年10月19日~2011年11月28日</td><td align="center">14</td></tr><tr><td align="center">4.0.3~4.0.4</td><td align="center">Ice Cream Sandwich(冰淇淋三明治)</td><td align="center">2011年12月16日~2012年2月6日</td><td align="center">15</td></tr><tr><td align="center">4.1~4.1.2</td><td align="center">Jelly Bean(果冻豆)</td><td align="center">2012年6月28~2012年10月9日</td><td align="center">16</td></tr><tr><td align="center">4.2~4.2.2</td><td align="center">Jelly Bean(果冻豆)</td><td align="center">2012年10月29日~2013年2月11日</td><td align="center">17</td></tr><tr><td align="center">4.3~4.3.1</td><td align="center">Jelly Bean(果冻豆)</td><td align="center">2013年7月24日~2013年10月5日</td><td align="center">18</td></tr><tr><td align="center">4.4</td><td align="center">Kitkat(奇巧巧克力棒)</td><td align="center">2013年7月24日</td><td align="center">19</td></tr><tr><td align="center">4.4W</td><td align="center">Kitkat Watch(奇巧巧克力棒)</td><td align="center">2014年6月</td><td align="center">20</td></tr><tr><td align="center">5.0</td><td align="center">Lollipop(棒棒糖)</td><td align="center">2014年6月25日</td><td align="center">21</td></tr><tr><td align="center">5.1</td><td align="center">Lollipop(棒棒糖)</td><td align="center">未知</td><td align="center">22</td></tr><tr><td align="center">6.0</td><td align="center">Marshmallow(棉花糖)</td><td align="center">2015年5月28日</td><td align="center">23</td></tr><tr><td align="center">7.0</td><td align="center">Nougat(牛轧糖)</td><td align="center">2016年5月18日</td><td align="center">24</td></tr><tr><td align="center">7.1</td><td align="center">Nougat(牛轧糖)</td><td align="center">2016年12月5日</td><td align="center">25</td></tr><tr><td align="center">8.0</td><td align="center">Oreo(奥利奥)</td><td align="center">2017年8月22日</td><td align="center">26</td></tr><tr><td align="center">8.1</td><td align="center">Oreo(奥利奥)</td><td align="center">2017年12月5日</td><td align="center">27</td></tr><tr><td align="center">9.0</td><td align="center">Pie(派)</td><td align="center">2018年8月7日</td><td align="center">28</td></tr><tr><td align="center">10.0</td><td align="center">Quince Tart(榅桲果塔)</td><td align="center">2019年5月8日</td><td align="center">29</td></tr><tr><td align="center">11.0</td><td align="center">Red Velvet Cake(红丝绒蛋糕)</td><td align="center">2020年9月9日</td><td align="center">30</td></tr><tr><td align="center">12.0</td><td align="center">Snow Cone(刨冰)</td><td align="center">2021年10月5日</td><td align="center">31</td></tr><tr><td align="center">12L</td><td align="center">Snow Cone(刨冰)</td><td align="center">2021年12月</td><td align="center">32</td></tr><tr><td align="center">13</td><td align="center">Tiramisu(提拉米苏)</td><td align="center">2022年2月11日</td><td align="center">33</td></tr><tr><td align="center">14</td><td align="center">Upside Down Cake(翻转蛋糕)</td><td align="center">2023年10月4日</td><td align="center">34</td></tr><tr><td align="center">15</td><td align="center">Vanilla Ice Cream(香草冰淇淋)</td><td align="center">2024年2月15日</td><td align="center">35</td></tr><tr><td align="center">16</td><td align="center">Baklava(巴克拉瓦)</td><td align="center">2024年11月18日</td><td align="center">36</td></tr></tbody></table><blockquote><p>安卓开发环境</p></blockquote><p>&emsp;&emsp;安卓开发所使用的语言是<strong>JAVA</strong>或<strong>Kotlin</strong>,底层操作使用<strong>C\C++</strong>。<br>&emsp;&emsp;安卓开发的工具主要有<strong>Eclipse</strong>或<strong>IDEA</strong>、<strong>Android Studio</strong>。其中<strong>Android Studio</strong>是官方指定的开发工具，推荐使用。而<strong>Eclipse</strong>目前(2020年2月14日)谷歌不再支持。推荐使用<strong>IDEA</strong>或<strong>Android Studio</strong>。</p><h5 id="注意！无论是设置SDK的路径或者是设置你的项目或者是其它的，都不能使用中文！也尽可能的去不用中文！"><a href="#注意！无论是设置SDK的路径或者是设置你的项目或者是其它的，都不能使用中文！也尽可能的去不用中文！" class="headerlink" title="注意！无论是设置SDK的路径或者是设置你的项目或者是其它的，都不能使用中文！也尽可能的去不用中文！"></a>注意！无论是设置SDK的路径或者是设置你的项目或者是其它的，都不能使用中文！也尽可能的去不用中文！</h5><p>Android Studio配置安卓开发环境可以有4步：<br><strong>1.配置JAVA开发环境。<br>2.安装Android Studio，下载Android SDK(安卓开发包)。<br>3.创建AVD(Android Android Virtual Device,安卓虚拟机)。<br>4.测试，运行。</strong></p><h6 id="配置JAVA环境"><a href="#配置JAVA环境" class="headerlink" title="配置JAVA环境"></a>配置JAVA环境</h6><p>请看<a href="https://lqzhi.github.io/2020/01/30/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">JAVA环境安装(1.8示例)</a>或者自行百度。这里不再说明。</p><h6 id="安装Android-Studio，下载Android-SDK。"><a href="#安装Android-Studio，下载Android-SDK。" class="headerlink" title="安装Android Studio，下载Android SDK。"></a>安装Android Studio，下载Android SDK。</h6><p>1.访问<a href="http://www.android-studio.org/index.php/">Android Studio中文社区</a>。下载Android Studio。<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/2.webp" alt="Android Studio中文社区"><br>或者访问<a href="https://developer.android.google.cn/about">Goolge Android官方开发主页</a>中选择Android Studio下载。<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/3.webp" alt="loading-ag-684"></p><p>2.安装Android Studio</p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/4.webp" alt="安装Android Studio1"><br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/5.webp" alt="安装Android Studio2"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/6.webp" alt="安装Android Studio3"><br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/7.webp" alt="安装Android Studio4"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/8.webp"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/9.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/10.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/11.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/12.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/13.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/14.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/15.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/16.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/17.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/18.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/19.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/20.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/21.webp" alt="AndroidStudio安装"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/22.webp" alt="AndroidStudio安装"></p><blockquote><p>创建AVD(Android Android Virtual Device,安卓虚拟机)</p></blockquote><p>AVD : Android Virtual Device安卓虚拟机。用于运行安卓软件。<br>(当然，你也可以选择安卓模拟器或者直接用真机调试。都是一样的)</p><h6 id="注意！部分需要开启CPU虚拟化才可以运行虚拟机-且需要Hyper-V虚拟机！"><a href="#注意！部分需要开启CPU虚拟化才可以运行虚拟机-且需要Hyper-V虚拟机！" class="headerlink" title="(注意！部分需要开启CPU虚拟化才可以运行虚拟机!且需要Hyper-V虚拟机！)"></a>(注意！部分需要开启CPU虚拟化才可以运行虚拟机!且需要Hyper-V虚拟机！)</h6><p>看下图！</p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/23.webp" alt="创建AVD1"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/24.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/25.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/26.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/27.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/28.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/29.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/30.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/31.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/32.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/33.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/34.webp" alt="创建AVD"></p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/35.webp" alt="创建AVD"></p><h6 id="查看自己的CPU是否开启虚拟化"><a href="#查看自己的CPU是否开启虚拟化" class="headerlink" title="查看自己的CPU是否开启虚拟化"></a>查看自己的CPU是否开启虚拟化</h6><p>打开任务管理器，点击性能</p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/36.webp" alt="查看是否开启虚拟化"></p><h6 id="开启Hyper-V虚拟机"><a href="#开启Hyper-V虚拟机" class="headerlink" title="开启Hyper-V虚拟机"></a>开启Hyper-V虚拟机</h6><h6 id="注意，Hyper-V虚拟机在Windows10家庭中文版是没有的。所以我们需要脚本安装Hyper-V虚拟机。"><a href="#注意，Hyper-V虚拟机在Windows10家庭中文版是没有的。所以我们需要脚本安装Hyper-V虚拟机。" class="headerlink" title="注意，Hyper-V虚拟机在Windows10家庭中文版是没有的。所以我们需要脚本安装Hyper-V虚拟机。"></a>注意，Hyper-V虚拟机在Windows10家庭中文版是没有的。所以我们需要脚本安装Hyper-V虚拟机。</h6><p>点击开始，搜索打开控制面板</p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/37.webp" alt="打开控制面板"></p><p>点击程序<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/38.webp" alt="loading-ag-1027"></p><p>打开启用或关闭Windows功能<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/39.webp" alt="loading-ag-1498"></p><p>勾选Windows虚拟机监控程序平台和Hyper-v<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/40.webp" alt="loading-ag-1499"></p><p>确定之后，会自动搜索文件安装。完成即可。<br>####Windows10家庭中文版安装Hyper-V<br>1.新键一个文本文件，复制一下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pushd &quot;%~dp0&quot;<br>dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt<br>for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;<br>del hyper-v.txt<br>Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL<br></code></pre></td></tr></table></figure><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/41.webp" alt="复制内容"></p><p>修改后缀名为<strong>bat</strong><br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/42.webp" alt="loading-ag-1522"></p><h6 id="然后管理员权限打开。等待安装完成。完成后按Y重启电脑，电脑配置完成后即可安装上Hyper-V虚拟机。"><a href="#然后管理员权限打开。等待安装完成。完成后按Y重启电脑，电脑配置完成后即可安装上Hyper-V虚拟机。" class="headerlink" title="然后管理员权限打开。等待安装完成。完成后按Y重启电脑，电脑配置完成后即可安装上Hyper-V虚拟机。"></a>然后管理员权限打开。等待安装完成。完成后按Y重启电脑，电脑配置完成后即可安装上Hyper-V虚拟机。</h6><p><strong>（注意！一定要管理员权限打开！！！）</strong></p><h6 id="测试，运行"><a href="#测试，运行" class="headerlink" title="测试，运行"></a>测试，运行</h6><p>（上面的步骤我都是Windows沙盒完成的，接下来我是在真机上面完成测试，运行。因为我真机的环境已经配置完成了。所以有许多在第一次里面这不会再出现。）</p><p>1.开启一个新的安卓项目<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/43.webp" alt="开启一个新的安卓项目"><br>2.选择一个模板，当然也可以不选择，然后，自己创建。<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/44.webp" alt="loading-ag-1566"></p><p>3.配置你的项目。需要注意以下几点！<br>(1.项目名不能有中文以及中文符号！)<br>(2.包名最少是两级，即最少包含一个小数点.例如a.a)</p><p><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/45.webp" alt="配置你的项目"></p><p>4.同步导入资源数据，或者设置你所需要开发的JDK<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/46.webp" alt="loading-ag-1580">5.编译完成<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/47.webp" alt="loading-ag-1585"></p><p>6.运行你的软件<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/48.webp" alt="loading-ag-1592"></p><p>7.成功运行<br><img src="/img/docs/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%92%8C%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83/49.webp" alt="loading-ag-1598"></p><blockquote><p>后话</p></blockquote><p>配置安卓环境比较复杂。其中自带的AVD需要根据每个人的不同进行去配置。所以，不推荐使用自带的AVD。只要有一个能够运行App的环境就行。可以使用安卓模拟器等。<br>安卓模拟器的话，个人推荐<del>夜神</del>。<a href="https://www.bluestacks.cn/">【BlueStacks安卓模拟器】安卓模拟器_Android模拟器_手游模拟器_蓝叠安卓模拟器官网</a>（&#x3D;-&#x3D;）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑客技术-盗取WIFI密码(二)</title>
    <link href="/2020/02/09/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%81-%E4%BA%8C/"/>
    <url>/2020/02/09/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%81-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>&emsp;&emsp;<strong>要盗取WIFI，我们首先要了解WIFI。</strong><br>&emsp;&emsp;WIFI(Wireless-Fidelity)是一种无线通信网络。其遵循的是<a href="https://baike.baidu.com/item/IEEE%20802.11/8447947?fr=aladdin">IEEE 802.11</a>协议。(有兴趣的可以了解一下 :<a href="https://blog.csdn.net/weixin_36178668/article/details/93622454">IEEE 802.11协议基础知识整理</a>)。</p><blockquote><p>说明</p></blockquote><p>&emsp;&emsp;本篇文章只是用来学习使用。不可转载和不可用于违法之事。天网恢恢，疏而不漏。自己犯下的错误，终究要自己承担。</p><blockquote><p>盗取WIFI前需要了解的一些东西</p></blockquote><p><strong>（WiFI是WLAN的一种标准，WIFI通常是短距离的，而WLAN是无线网络网，范围覆盖面更广。）</strong><br>&emsp;&emsp;<strong>WLAN主要由站(Station，STA)、接入点(Access Point，AP)、无线介质( Wireless Medium，WM)和分布式系统(Wireless Distribution System，WDS)组成。</strong><br>(下面是个人理解。不太专业。嘻嘻)</p><p>AP:也就是无线接入点。其是无线网络的创造者，也是网络的中心节点。可以理解成发送信号的东西。例如，路由器,手机(热点),电脑等。</p><p>STA:每一个连接到信号的终端设备。例如，手机，路由器,电脑等。</p><p>(AP模式中，路由器为一级路由器，直接连接网线。手机和电脑分别处于开着热点的状态。)<br>(STA模式中,路由器一般为二级路由器及其以下的路由器,通过无线或有线来继承上一级路由器的网络。手机和电脑都为连接WLAN的终端设备。)</p><p>WM：无线介质，网络通过无线介质进行传播。常用的由无线电波、微波和红外线。<br>WDS：无线分布式系统。</p><p>(WDS简单来讲，就是可以让无线网络进行桥接(中继)，且不影响其它AP覆盖的能力。最常用的就是WIFI放大器。)</p><p>好了。基本上懂了WLAN的4大组成。我们再了解一些其它的名称:<br>&emsp;&emsp;1.SSID(Service Set Identifier,服务集标识) ：SSID技术可以将一个无线局域网分为几个需要不同身份验证的子网络，每一个子网络都需要独立的身份验证，只有通过身份验证的用户才可以进入相应的子网络，防止未被授权的用户进入本网络。来自<a href="https://baike.baidu.com/item/SSID/10823867?fr=aladdin">百度百科-SSID</a>（通俗的来说，就是你的WIFI名字。一个路由器可以设置多个SSID，允许用户连接到不同的网络中。当然，实际上所有的用户还是连接到了同一个无线网络，只是各一组SSID的用户都是分开的而已，互不相通。网络数据是隔开的。）<br>&emsp;&emsp;2.Wireless channel(无线信道):无线信道可以看作是发送端(AP)到接收端(STA)的一种无形的传输通道。是信号传输的媒介。其中根据各国标准制定的不同，信道个数也有不同。</p><table><thead><tr><th align="center">地区</th><th align="center">信道</th></tr></thead><tbody><tr><td align="center">北美&#x2F;FCC</td><td align="center">2.412-2.461GHz(11信道)</td></tr><tr><td align="center">欧洲&#x2F;ETSI</td><td align="center">2.412-2.472GHz(13信道)</td></tr><tr><td align="center">中国&#x2F;</td><td align="center">2.412-2.472GHz(13信道)</td></tr><tr><td align="center">日本&#x2F;ARIB</td><td align="center">2.412-2.484GHz(14信道）</td></tr></tbody></table><p>&emsp;&emsp;3.IP地址(Internet Protocol,网际互连协议):是TCP&#x2F;IP体系中的网络层协议.通常当一个STA终端连接上AP时，AP会分配一个IP地址给终端。当网络数据需要路由转发时，如果目标主机与本地路由器之间连接，即直接将数据包扔给目标主机。(直接交付)否则，路由器将会查询路由表查找路由信息，并将数据包转交给指明的下一跳路由器。(间接交付)<br>(IP地址用于网络传输。网络的传输的数据包需要到哪里去主要是通过IP地址来查询的。)<br>&emsp;&emsp;4.MAC地址(Media Access Control Address，媒体存取控制位址):也称局域网地址(LAN Address），MAC位址，以太网地址（Ethernet Address）或物理地址（Physical Address）。它是一个用来确认网络设备位置的位址。在<a href="https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>中，第三层网络层负责<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>，第二层数据链路层则负责MAC位址<sup> [1]</sup>  。MAC地址用于在网络中唯一标示一个<a href="https://baike.baidu.com/item/%E7%BD%91%E5%8D%A1">网卡</a>，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址。来自<a href="https://baike.baidu.com/item/MAC%E5%9C%B0%E5%9D%80/1254181?fr=aladdin">百度百科-MAC地址</a>。<br>(MAC地址主要是确定网络设备位置。一张网卡会用一个MAC地址。其通常由厂家分配并烧录到网卡芯片中的，具有全球唯一性，和人的指纹一样可以作为网卡识别以及底层物理传输中识别主机的重要信息。一般来说，其不能更改，但是，还是可以通过一些技术来修改MAC地址。)<br>&emsp;&emsp;5.网关(Gateway):又称网间连接器、协议转换器。网关主要用于高层不同协议的连接。通俗来讲，网关就是一个网络连接另外一个网络的门。<a href="https://baike.baidu.com/item/%E7%BD%91%E5%85%B3/98992?fr=aladdin">百度百科-网关</a>。<br>（网关起到的就是桥梁的作用。数据包会经过网关。）</p><blockquote><p>盗取WIFI密码(五):利用arp欺骗</p></blockquote><p>&emsp;&emsp;ARP是什么？<br>ARP(Address Resolution Protocol):地址解析协议。将IP地址转换成MAC地址，以此来确定网络设备。注意一点：ARP协议是建立在网络中各个主机互相信任的基础上的。(<strong>网络设备之间的互相通信并不是通过IP地址来确定，而是MAC地址。每台主机都又一个ARP缓存表，记录着IP地址所对应的MAC地址。</strong>)<br><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%812/1.webp" alt="APR通信.png"><br>&emsp;&emsp;什么是ARP欺骗呢？<br>很简单。假设有终端A,终端B和网关C。当数据包要从A发生给B时，A会先发生数据包给网关C，然后网关C再把数据发生给B。这时候，我们可以利用自己的电脑，‘假扮’网关C，获取A的数据后，经过修改，再发送给B。<br><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%812/2.webp" alt="ARP双向欺骗.png"><br>APR的单向欺骗也很简单，只要我们发送一个伪造返回包给A(IP地址是网关的IP地址，MAC为我们的MAC地址)。这样，A会把数据返回给我们，而网关还是会把数据包给A。就是指，A只能接受数据，不能发送数据给别人(因为我们拦截了。)<br>（推荐博客 :<a href="https://www.jianshu.com/p/d6f84e2e88c6">中间人攻击——ARP欺骗的原理、实战及防御</a>）</p><blockquote><p>如何利用ARP欺骗盗取WIFI密码呢？</p></blockquote><p>三步：<br>1.引诱他人连接我们的wifi<br>2.arp欺骗。<br>3.发送伪造网站，让他人输入WIFI密码。</p><h5 id="注意！请不要随意在网站上输入密码。"><a href="#注意！请不要随意在网站上输入密码。" class="headerlink" title="(注意！请不要随意在网站上输入密码。)"></a>(注意！请不要随意在网站上输入密码。)</h5><p>第一步：因为ARP欺骗的前提是，在同一个局域网内才可以生效。这时候我们又不知道WIFI密码，没办法进入到局域网中。这时候怎么办呢？很简单，让他们连接我们的WIFI。(<strong>所以，注意不要随便连接WIFI！！</strong>)<br><br><strong>引诱他人连接WIFI</strong><br>首先：我们要进行无线DOS攻击。让其WIFI无法连接。(WIFI杀手)<br>(无线DOS攻击的相关资料:<a href="https://www.freebuf.com/articles/wireless/135598.html">常见无线DOS攻击</a>,可以使用Aircrack-ng进行DoS攻击，在此处不在说明。)<br>然后,我们再开一个SSID和目标SSID一样的热点WIFI。这样，便可以让他人连接我们的WIFI。<br><br>第二步：进行arp欺骗。<br>介绍一个工具:arpspoof<br>（因为自己很久没搞过了。忘掉差不多了。当时是使用Kail Linux进行的。现在懒得安装了。所以，我也就不展示了。等自己无聊再搞一个视频上来。）<br>arp欺骗博客:# <a href="https://www.cnblogs.com/xcj26/articles/6073411.html">使用ARP欺骗, 截取局域网中任意一台机器的网页请求,破解用户名密码等信息</a>。</p><p>第三步：利用arp发送伪造网站。(可以发送一个路由器更新的网站。骗一般人没问题。)然后成功获取Wifi密码。<br>(注意：请不要使用arp欺骗去做违法之事。)</p><blockquote><p>盗取WIFI密码(六):利用Aircrack-ng工具</p></blockquote><p><strong>Aircrack-ng</strong>是一个与<a href="https://baike.baidu.com/item/802.11">802.11</a>标准的无线网络分析有关的安全软件，主要功能有：网络侦测，数据包嗅探，<a href="https://baike.baidu.com/item/WEP">WEP</a>和<a href="https://baike.baidu.com/item/WPA">WPA</a>&#x2F;WPA2-PSK破解。(<a href="https://baike.baidu.com/item/aircrack-ng/7661805?fr=aladdin">百度百科- Aircrack-ng</a>)<br>(&#x3D;-&#x3D;同上。没有安装Kail Linux。所以没有这个软件。而且，我下载了它的Windows版本。发现好像要搭配一个驱动dll。因为aircrack-ng需要无线网卡。所以，在此也不再展示了。)<br>aircrack-ng盗取WIFI主要有以下几步。<br>1.切换无线网网卡模式为监听模式。<br>2.搜索AP信号<br>3.监听WIFI，尝试抓取wifi握手包。<br>4.发送攻击，连接的终端断线。<br>5.抓取成功后，跑字典破解(这边最难，看WIFI密码难度而定。如果WIFI密码复杂，那就别想了。<br>（如何使用aircrack-ng破解WIFI密码推荐博客:<a href="https://blog.csdn.net/qq_36119192/article/details/84254622">Aircrack-ng破解无线WIFI密码</a></p><blockquote><p>盗取WIFI密码(七)：其它工具</p></blockquote><p>其实破解WIFI密码的工具还有很多，像Beini（奶瓶）、BackTrack5都可以破解WIFI。所以，多多必应即可呀。</p><blockquote><p>个人后话</p></blockquote><p>盗取WIFI这件事，当WIFI密码设置很复杂时，WIFI密码根本就破解不了。<br>这是WIFI的几种加密方式：<a href="https://blog.csdn.net/iteye_19603/article/details/82363931">wifi 的几种加密方式</a>。<br>通常现在的WIFI都是WPA-PSK+WPA2-PSK。密码好像只能通过跑字典了。但是字典并不是那么好跑的。除非密码是123456。<br>其实这种技术并不能算是黑客技术。只能说是脚本小子。一个真正的黑客，往往需要掌握大量的底层知识，对操作系统以及各种协议都是了如指掌的。那是多么庞大的知识量啊。自己还是算了吧。</p>]]></content>
    
    
    <categories>
      
      <category>黑客技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黑客技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑客技术-盗取WIFI密码(一)</title>
    <link href="/2020/02/08/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%81-%E4%B8%80/"/>
    <url>/2020/02/08/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%81-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>          有点无聊&#x3D;-&#x3D;。本来不行更新的。谁知道自己参加了日更活动。不更不行啊。可是又没有时间接着写数据结构(因为现在已经17点54分了。)所以，打算就把自己以前因为宿舍没有Wifi。而去苦学的Wifi盗取技术(我只是学了一部分)。因为这是我自己自学的。所以讲的不好请不要介意。盗取Wifi我会分成2个部分。一个是技术含量少一点的。一个是需要一些技术含量和了解的。(今天的技术含量少不代表没有技术含量。)</p><hr><blockquote><p>说明</p></blockquote><h4 id="本篇文章只是用来学习使用。不可转载和不可用于违法之事。天网恢恢，疏而不漏。自己犯下的错误，终究要自己承担。"><a href="#本篇文章只是用来学习使用。不可转载和不可用于违法之事。天网恢恢，疏而不漏。自己犯下的错误，终究要自己承担。" class="headerlink" title="本篇文章只是用来学习使用。不可转载和不可用于违法之事。天网恢恢，疏而不漏。自己犯下的错误，终究要自己承担。"></a>本篇文章只是用来学习使用。不可转载和不可用于违法之事。天网恢恢，疏而不漏。自己犯下的错误，终究要自己承担。</h4><hr><blockquote><p>盗取WiFI密码(一)</p></blockquote><p>直接找主人问(<strong>强烈推荐。没什么技术含量。</strong>)</p><hr><blockquote><p>盗取WiFI密码(二)</p></blockquote><p>当你爱要面子或者主人不在时，你可以选择使用万能WiFi钥匙破解。也可以使用Wifi钥匙破解也行。再不济也可以使用腾讯Wifi管家。反正到处找Wifi破解软件就行。</p><hr><blockquote><p>盗取WiFI密码(三)</p></blockquote><p>前面两个或许没有什么技术含量。那么。让我们来一点技术含量的。</p><p><strong>首先，准备一个CD-ROM U盘(容量随便)；</strong></p><p>然后。让我们了解我们该如何用CD-ROM U盘盗取WiFi。</p><p>（在使用该方法时。有两大前提！一：你得让你的U盘能够插入到连接有WIFI的Windows电脑。二：没有关闭U盘的自动播放功能。）</p><p><strong>在U盘中设置好我们的盗取WIFI程序。然后再想个办法插入到电脑中去。</strong>(是不是很像电影里面的黑客大佬，U盘一插，整个系统都崩溃了。)</p><p>好了。就是这么简单。那么。<strong>重点是<em>如何制作WIFI盗取程序呢？制作成功了又如何运行呢？</em></strong></p><blockquote><p><strong>解决自动运行(Windows环境下)：Autorun.inf文件</strong></p></blockquote><p>Autorun.inf文件是什么文件呢?</p><p><strong>Autorun.inf原本是在Windows下用来对光盘播放操作的一种文件。例如:插入某光盘时能够自动运行安装程序。这就得归功于Autorun.inf文件。</strong></p><p><strong>在<a href="%5Bautorun.inf_%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91%5D(https://baike.baidu.com/item/autorun.inf/10548193?fr=aladdin)">百度百科</a>:<em>autorun.inf是我们电脑使用中比较常见的文件之一 ，其作用是允许在双击<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98/2842227">磁盘</a>时自动运行指定的某个文件。但是近几年出现了用autorun.inf文件传播<a href="https://baike.baidu.com/item/%E6%9C%A8%E9%A9%AC/530">木马</a>或病毒，它通过使用者的误操作让<a href="https://baike.baidu.com/item/%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F/8082041">目标程序</a>执行，达到侵入电脑的目的，带来了很大的负面影响。(请不要去传播病毒。)</em></strong></p><p>Autofun.inf制作:</p><p>Autofun.inf主要有三大部分:</p><p>[AutoRun];</p><p>[AutoRun.Alpha];</p><p>[DeviceInstall];</p><p>其中，[AutoRun]适用于Windows 95以上版本的系统与32位以上的CD-ROM。[AutoRun.Alpha]适用与基于RISC(精简指令集计算机)的计算机光驱以及Windows NT 4.0以上系统版本.[DeviceInstall]适用于Windows XP以上系统。</p><p>其中[AutoRun]为必选项。[AutoRun.Alpha]和[DeviceInstall]为可选项。</p><p>下面大致上讲解一下Autofun.inf的文件参数:</p><p><strong>1.DefaultIcon : 指定应用程序的默认图标。</strong></p><p><strong>2.Icon:指定设备显示图标</strong></p><p><strong>3.Label：指定设备描述</strong></p><p><strong>4.Open:指定启用该设备时运行的命令行(我们待会就用这个。)</strong></p><p><strong>5.ShellExecute:指定启用该设备时运行的文件</strong></p><p><strong>6.Shell 关键字 Command：定义设备右键快捷菜单执行命令行</strong></p><p><strong>7.Shell 关键字:定义设备右键快捷菜单文本</strong></p><p><strong>8.Shell:定义设备启用时运行的设备右键快捷菜单命令。</strong></p><p>*我们如何使用这些呢？举个栗子：</p><p><em><strong>修改U盘图标</strong></em></p><p>在U盘的主目录下创建一个autorun.inf文件和一个.ico图标文件。(图标文件自己去下载.需要是ico的。也可以是安装文件。我放的是360的安装文件可以隐藏)。在文件中这样写道:</p><p><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%811/1.webp">  </p><p>autorun.inf</p><p><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%811/2.webp">  </p><p>U盘主目录</p><p><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%811/3.webp">  </p><p>打开后的样子</p><p><strong>好了。自动运行解决了。接下来就是如何编写软件了。</strong></p><p><strong>在编写软件之前。我先放出几个命令行指令；</strong></p><blockquote><p>&#x2F;&#x2F; 列出所有可用wifi</p><p>netsh wlan show networks mode&#x3D;bssid</p><p>&#x2F;&#x2F; 添加配置文件</p><p>netsh wlan add profile filename&#x3D;FILE_NAME</p><p>&#x2F;&#x2F; 连接wifi</p><p>netsh wlan connect name&#x3D;SSID_NAME</p><p>&#x2F;&#x2F; 导出配置文件</p><p>netsh wlan export profile key&#x3D;clear</p><p>&#x2F;&#x2F; 列出配置文件</p><p>netsh wlan show profile</p><p>&#x2F;&#x2F; 删除配置文件</p><p>netsh wlan delete profile name&#x3D;FILE_NAME</p><p>&#x2F;&#x2F; 列出接口</p><p>netsh wlan show interface</p><p>&#x2F;&#x2F; 开启接口</p><p>netsh interface set interface “Interface Name” enabled</p></blockquote><p>这些是Windows下的命令行。</p><p>我们可以使用这些命令行帮我们解决导出WIFI密码的问题。其中，最好用的便是netsh wlan export profile key&#x3D;clear(导出配置文件)。</p><p>我们在U盘其它目录下，写一个bat(批命令处理).将netsh wlan export profile key&#x3D;clear直接复制进去。然后保存，退出。</p><p><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%811/4.webp">  </p><p>批命令处理</p><p>然后用AutoRun.inf执行该文件后，你就会发现，在该目录下多出几个文件。</p><p><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%811/5.webp">  </p><p>执行后</p><p>每个文件就是单个WIFI的配置。</p><p><img src="/img/docs/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF-%E7%9B%97%E5%8F%96WIFI%E5%AF%86%E7%A0%811/6.webp">  </p><p>WIFI.xml</p><p>没错。这样，你就可以偷到WIFI了。</p><p>可是</p><blockquote><p><strong>当用户使用包含autorun.inf文件的USB设备、网络共享或其它非CD&#x2F;DVD媒体时，系统不会执行自动运行。</strong></p></blockquote><p>梦想总是好的。现实可是很残酷。目前这个方法我一直没有成功过。为什么呢？因为autorun.inf一般在电脑里面，大家都关闭了这个功能。所以。&#x3D;-&#x3D;没用。但是好歹也是自己的一个想法，而且上面的命令行也比较好使用。(看Wifi密码挺不错的。)</p><p>当然，你也可以插进去后。以迅雷不及掩耳直接运行net.bat。然后快速拔下来。Wifi密码也是可以被偷到的。</p><p>哈哈哈哈哈哈哈哈。其实吧，这并不能算是黑客技术。毕竟只是进行了批命令处理而已。</p><p>不过呢，当你可以触碰到电脑时，你完全可以写一个修改注册表，自动运行，每时每刻检测系统Wifi是否被修改，用Socket作为连接的软件(这可以说是病毒了)。运行之后隐藏起来之类的。这样Wifi也可以算是偷到了。但是我估计这以及触碰法律了。</p><p>编程是一件快乐的事情。但是当使用编程来做坏事时，它就不快乐了。</p><p>明天可以说一下真正的黑客技术，盗取WiFI密码。利用网络攻击进行抓包处理。然后跑字典。或者arp欺骗，直接让主人傻兮兮的输入密码的那种。</p>]]></content>
    
    
    <categories>
      
      <category>黑客技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黑客技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表的链式存储结构</title>
    <link href="/2020/02/06/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2020/02/06/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>&emsp;&emsp;在前面<a href="https://lqzhi.github.io/2020/02/03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">线性表的顺序存储结构</a>和<a href="https://lqzhi.github.io/2020/02/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95-%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8/">线性表的顺序存储结构扩展(动态顺序表)</a>中我们了解到线性表的顺序存储结构。我们能够了解到其顺序表的优缺点。我们知道，顺序表的查找和更新是十分快的。通过下标索引的话，其时间复杂度为常数阶。但是，我们在进行插入，删除的时候，我们发现，我们通常需要移动大量的数据才可以完成。有没有什么存储结构能够快速的插入和删除呢？<br>当然有，那就是<a href="https://baike.baidu.com/item/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/4921270?fr=aladdin">链式存储结构</a>。</p><blockquote><p>顺序表的链式存储结构</p></blockquote><p>&emsp;&emsp;链式存储结构，又叫链接存储结构。在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>中用一组任意的存储单元存储线性表的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313">数据元素</a>(这组存储单元可以是连续的,也可以是不连续的).【1】<br>&emsp;&emsp;链式存储结构的存储单元通常是不连续的，其每一个数据结点通常是由两个域组成。<strong>数据域</strong>和<strong>指针域</strong>(我通常认为指针域为关系域，因为部分语言并没有指针。以下，我会将指针域改成关系域)。然后每一个数据结点进行连接。</p><h6 id="数据域-：存放数据的地方。"><a href="#数据域-：存放数据的地方。" class="headerlink" title="数据域 ：存放数据的地方。"></a>数据域 ：存放数据的地方。</h6><h6 id="关系域-指针域-：存放数据之间关系的地方。"><a href="#关系域-指针域-：存放数据之间关系的地方。" class="headerlink" title="关系域(指针域) ：存放数据之间关系的地方。"></a>关系域(指针域) ：存放数据之间关系的地方。</h6><p>其存储结构抽象类型为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ADT 链式存储结构&#123;<br>    数据域：存放数据<br>    关系域(指针域)：存放数据之间的关系<br>&#125;结点<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>那么数据之间是如何联系的呢？下看图:<br>  <img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1.webp" alt="举个栗子图"><br>**因为链式结构的对数据的关系是通过</p><blockquote><p>链表</p></blockquote><p>&emsp;&emsp;链表，是其线性表的链式存储结构的简称。链表通常有：单链表、双向链表、循环链表、循环双向链表、静态链表，循环静态链表、循环静态双向链表等等。<br>单链表大致如下图(这个是我学链表的时候理解画的。偷一下懒)<br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/2.webp" alt="loading-ag-217"><br>掌握了单链表，除了静态链表之外，其它都比较好掌握。</p><blockquote><p>单链表的方法</p></blockquote><ol><li>构造单链表</li></ol><p>&emsp;&emsp;在构造单链表之前，我们首先要了解到一个概念：<strong>首元结点</strong>和<strong>头结点</strong>。</p><p><strong>首元结点：带有数据的第一个结点。</strong></p><p><strong>头结点：首元结点的直接前驱结点，其没有直接前驱。</strong></p><p><strong>(带头结点的链表和不带头结点的链表)</strong><br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/3.webp" alt="首元结点和头结点"><br>(为什么要带一个头结点呢？这不白白增。）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">(带头结点的的链表)<br><span class="hljs-function"><span class="hljs-title">newNode</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = header-&gt;</span>next;<span class="hljs-comment">//新添加的结点先保存好原先的数据。指向首元结点</span><br><span class="hljs-function"><span class="hljs-title">header</span>-&gt;</span>next = newNode;<span class="hljs-comment">//再将头结点的指针域指向新添加的结点。</span><br>(不带头结点的链表)<br><span class="hljs-function"><span class="hljs-title">newNode</span>-&gt;</span>next = header;<span class="hljs-comment">//先保存好原先的数据。即添加结点的关系域(指针域)指向首元结点</span><br>header = newNode;<span class="hljs-comment">//修改头指针</span><br></code></pre></td></tr></table></figure><p><em><strong>2.尾插法：</strong></em><br><strong>1.先找到尾结点。</strong><br><strong>2.尾结点的指针域指向新添加的结点。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust">(没有尾结点的链表)<br>Node <span class="hljs-keyword">move</span> = new Node;<span class="hljs-comment">//创建一个移动的指针。(不能用头指针去寻找尾结点，因为头指针是整个链表的标识。如果我们找不到头结点的时候，我们就找不到链表了。)</span><br><span class="hljs-comment">//带有头结点的链表</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">move</span> <span class="hljs-punctuation">-&gt;</span>next != NULL)&#123;<span class="hljs-comment">//循环找到尾结点</span><br>    <span class="hljs-keyword">move</span> = <span class="hljs-keyword">move</span><span class="hljs-punctuation">-&gt;</span>next;<br>&#125;<br><span class="hljs-comment">//不带头结点的链表</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">move</span> != NULL)&#123;<span class="hljs-comment">//循环找到尾结点</span><br>    <span class="hljs-keyword">move</span> = <span class="hljs-keyword">move</span><span class="hljs-punctuation">-&gt;</span>next;<br>&#125;<br>newNode<span class="hljs-punctuation">-&gt;</span>next = <span class="hljs-keyword">move</span><span class="hljs-punctuation">-&gt;</span>next;<span class="hljs-comment">//先保存好尾部结点的指针域。(单链表尾结点为NULL)</span><br><span class="hljs-keyword">move</span><span class="hljs-punctuation">-&gt;</span>next = newNode;<span class="hljs-comment">//尾部结点指向新添加的数据。</span><br>(有尾结点的链表)<br>newNode<span class="hljs-punctuation">-&gt;</span>next = tail<span class="hljs-punctuation">-&gt;</span>next;<span class="hljs-comment">//先保存好尾部结点的指针域</span><br>tail  = newNode;<span class="hljs-comment">//尾部结点指向新的结点</span><br></code></pre></td></tr></table></figure><p>###插入数据<br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/4.webp" alt="loading-ag-231"></p><p><strong>方法：</strong><br><strong>1.找到需要插入结点的前一个结点。</strong><br><strong>2.将插入结点的指针域指向第一步找到结点的指针域。</strong>(保存数据，防止数据丢失)<br><strong>3.将第一步找到的结点的指针域指向插入结点</strong><br>(不需要移动大量的数据，只需要移动指针即可。)</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl">(设需要将newNode结点插入到insertNode结点之前)<br>Node move = new Node;<span class="hljs-comment">//创建一个移动的指针。(不能用头指针去寻找尾结点，因为头指针是整个链表的标识。如果我们找不到头结点的时候，我们就找不到链表了。)</span><br><span class="hljs-comment">//带有头结点的链表(没有头结点特别不好插入。各种判断。这里就不进行了。)</span><br><span class="hljs-function"><span class="hljs-title">while</span>(move-&gt;</span>next != NULL)&#123;<span class="hljs-comment">//循环遍历，查找的数据的前一个结点。</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (move-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span> == insertNode-&gt;</span><span class="hljs-keyword">data</span>)&#123;<span class="hljs-comment">//查找到前一个结点</span><br>         break;         <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">move</span> = move-&gt;</span>next;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">newNode</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = move -&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>;//(move为插入结点的前一个结点.move-&gt;</span>next指向的就是insertNode)<br><span class="hljs-function"><span class="hljs-title">move</span>-&gt;</span>next = newNode;<span class="hljs-comment">//插入新结点</span><br></code></pre></td></tr></table></figure><p>###删除数据<br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/5.webp" alt="loading-ag-240"></p><p><strong>方法：</strong><br><strong>1.找到需要删除结点的前一个结点。</strong><br><strong>2.保存第一步找到的结点的指针域。</strong><br><strong>3.将第一步找到的结点的指针域等于下一个结点的指针域。</strong><br><strong>3.释放第二步保存的指针域。</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xl">(设需要删除delNode结点)<br>Node move = new Node;<span class="hljs-comment">//创建一个移动的指针。(不能用头指针去寻找尾结点，因为头指针是整个链表的标识。如果我们找不到头结点的时候，我们就找不到链表了。)</span><br><span class="hljs-comment">//带有头结点的链表</span><br><span class="hljs-function"><span class="hljs-title">while</span>(move-&gt;</span>next != NULL)&#123;<br>      <span class="hljs-function"><span class="hljs-title">if</span>(move-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span> == delNode-&gt;</span><span class="hljs-keyword">data</span>)&#123;<span class="hljs-comment">//第一步：判断是否为需要删除的结点(move是需要删除结点的前一个结点的)</span><br>              N<span class="hljs-function"><span class="hljs-title">ode</span> del = move-&gt;</span>next;<span class="hljs-comment">//第二步：保存需要删除的结点</span><br>              <span class="hljs-function"><span class="hljs-title">move</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = move-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;<span class="hljs-comment">//第三步：删除结点</span><br>              delete del;<span class="hljs-comment">//第四步:释放内存</span><br>              break;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-title">move</span> = move-&gt;</span>next;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><p> 链式存储结构使用与大量的插入和删除操作。其不适合与查找操作。因为其查找每次都的遍历整个链表。而且。链式存储结构会比顺序存储结构多一个空间。用来存放数据的关系。且链式存储结构不需要连续的空间。而顺序存储结构一定是连续的。</p><p>链式存储结构的抽象类已经在<a href="https://lqzhi.github.io/2020/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</a>给出。</p><p>参考资料:【1】<a href="https://baike.baidu.com/item/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/4921270?fr=aladdin">百度百科-链式存储结构</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表的顺序存储结构扩展(动态顺序表)</title>
    <link href="/2020/02/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95-%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    <url>/2020/02/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95-%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>在<a href="https://lqzhi.github.io/2020/02/03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/">线性表的顺序存储结构</a>中，我们了解了顺序存储结构的优缺点。我们注意到，其固定的静态特性对于日常来说特别不太友好。因为我们有时无法把握数据量的大小。如果我们存储大小定小了，那么存储空间可能不够。如果我们存储大小定义大了，那么又会造成空间浪费。所以，针对这种情况，我们可以使用链式结构(推荐)和动态顺序表(动态数组也是一样。)。所以，今天就来记录一下，动态顺序表。</p><blockquote><p>动态顺序表原理</p></blockquote><p><strong>1.首先，我们要了解到，当我们申请了一个固定大小的空间时，我们是没有办法在其空间上往后面进行扩容。(不能原地扩容)</strong><br>2.所谓的动态，其核心在与 ： <em><strong>在另外一处重新开辟一个比原先空间还有大的空间，将原先的空间中的数据转移到新开的数据，再释放掉原先的空间即可。</strong></em><br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/1.webp" alt="扩容图"><br><strong>3.扩容有两种方式。</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">//malloc函数因为常用，被包含在iostream中，C++可以直接使用。</span></span><br><span class="hljs-comment">//#include&lt;stdlib.h&gt; malloc是C语言的申请内存函数。其包含在stdliib.h头文件中。</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用: 数据类型 * 指针变量名 = (数据类型 *) malloc (大小 * sizeof(数据类型) );</span><br>    <span class="hljs-comment">//注意强制转换和sizeof获取数据类型所需要的空间大小。</span><br>    <span class="hljs-comment">//例如int * p = (int *) malloc (sizeof(int)) ; 申请一个int类型的数据</span><br>    <span class="hljs-type">int</span> * p = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span> ( <span class="hljs-number">10</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) );<span class="hljs-comment">//申请一个int类型的数组。空间大小为10</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        p[i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>        cout&lt;&lt;p[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;PAUSE&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/2.webp" alt="malloc函数使用"><br>realloc: 原型void *realloc(void *_Memory, size_t _NewSize)。传入的参数为需要动态调整的空间，以及新的空间大小，新的空间大小可以比原先的空间大小大，也可以比原先空间大小小。<br> 使用总结  【<a href="https://baike.baidu.com/item/realloc/659993?fr=aladdin">百度百科 - realloc</a>】<br>1. realloc失败的时候，返回NULL<br>2. realloc失败的时候，原来的内存不改变，不会释放也不会移动<br>3. 假如原来的内存后面还有足够多剩余内存的话，realloc的内存&#x3D;原来的内存+剩余内存,realloc还是返回原来内存的地址; 假如原来的内存后面没有足够多剩余内存的话，realloc将申请新的内存，然后把原来的内存数据拷贝到新内存里，原来的内存将被free掉,realloc返回新内存的地址<br>4. 如果size为0，效果等同于free()。这里需要注意的是只对<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>本身进行释放，例如对二维指针**a，对a调用realloc时只会释放一维，使用时谨防<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">内存泄露</a>。<br>5. 传递给realloc的指针必须是先前通过<a href="https://baike.baidu.com/item/malloc">malloc</a>(), <a href="https://baike.baidu.com/item/calloc">calloc</a>(), 或realloc()分配的<br>6.传递给realloc的指针可以为空，等同于malloc。</p><p>举例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">//realloc函数因为常用，被包含在iostream中，C++可以直接使用。</span></span><br><span class="hljs-comment">//#include&lt;stdlib.h&gt; realloc是C语言的动态内存调整函数。其包含在stdliib.h头文件中。</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用: 数据类型 * 指针变量名 = (数据类型 *) realloc (需要调整空间的指针名 ,大小 * sizeof(数据类型) );</span><br>    <span class="hljs-comment">//注意强制转换和sizeof获取数据类型所需要的空间大小。以及调整空间的指针名。</span><br>    <span class="hljs-type">int</span> * p = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span> ( <span class="hljs-number">10</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) );<span class="hljs-comment">//申请一个int类型的数组。空间大小为10</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        p[i] = i;<br>    &#125;<span class="hljs-comment">//放入10个数据</span><br>    <span class="hljs-comment">//动态调整空间:扩容</span><br>    p = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">realloc</span> ( p, <span class="hljs-number">20</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//扩容。再增加10个空间。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &lt; <span class="hljs-number">20</span>; i++)&#123;<br>        p[i] = i;<br>    &#125;<br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)&#123;<br>        cout&lt;&lt;p[i]&lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<span class="hljs-comment">//回车</span><br>    <span class="hljs-comment">//动态调整空间:缩小</span><br>    p = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">realloc</span> (p ,<span class="hljs-number">10</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) );<span class="hljs-comment">//缩小。回归到10个空间大小，会引发数据被丢失</span><br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)&#123;<span class="hljs-comment">//继续循环到20个，会引发错误。</span><br>        cout&lt;&lt;p[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<span class="hljs-comment">//回车</span><br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;PAUSE&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>后面的数据被丢失了。<br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/3.webp" alt="realloc函数使用"><br>free :原型void free(void *ptr)。释放指针所执向的空间。（该不举例。）</p><p>(2)使用new，delete函数。和自己移动数据。(&#x3D;-&#x3D;)。<br>使用方法很简单。先new一个新的空间，然后把原先数据移动过去。再delete原先的空间。</p><blockquote><p>动态顺序表结构类实现</p></blockquote><p>(只是在顺序表结构类上重写了insert函数以及增加了一个addStorage()函数和返回容量大小的capacity()函数。&#x3D;-&#x3D;之前卡在了addStorage()函数那个释放那里，卡了将近4个小时。慢慢的了解到了new&#x2F;delete，malloc&#x2F;free的关系。new&#x2F;delete是一对操作符，是对于对象进行的。delete在释放内存之前还会调用析构函数回收内存。malloc&#x2F;free主要是针对内存的。唉，自己要走的路还很长呀。<br>推荐博客：<a href="https://blog.csdn.net/hazir/article/details/21413833">浅谈 C++ 中的 new&#x2F;delete 和 new[]&#x2F;delete[]</a><br><a href="https://blog.csdn.net/porryCn/article/details/80284055">C++ 动态内存管理(new &#x2F;delete-new[]&#x2F;delete[]-N次释放)</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态顺序表类</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> : <span class="hljs-keyword">public</span> ListSelf&lt;T&gt;&#123;<span class="hljs-comment">//List : 动态顺序表类 继承 顺序存储结构抽象类(ListSelf)</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> SIZE = <span class="hljs-number">10L</span>;<br>        T * data;<span class="hljs-comment">//数据首地址</span><br>        <span class="hljs-type">size_t</span> length ;<span class="hljs-comment">//数据长度大小</span><br>        <span class="hljs-type">size_t</span> storage;<span class="hljs-comment">//整体大小</span><br>        <span class="hljs-comment">//核心函数</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 扩容函数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">Status <span class="hljs-title">addStorage</span><span class="hljs-params">(T elem,<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len = length != <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> * length : <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//利用三元运算符，如果原大小为0，则分配为1</span><br>            <span class="hljs-comment">//否则分配原大小的两倍</span><br><br>            <span class="hljs-comment">//分配内存</span><br>            T * newData = <span class="hljs-keyword">new</span> T[len];<br>            <span class="hljs-keyword">if</span> (!newData)&#123;<br>                <span class="hljs-keyword">return</span> FAIL;<br>            &#125;<br><br>            <span class="hljs-comment">//移动数据</span><br>            <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; index ; i++)&#123;<span class="hljs-comment">//先移动前面的数据</span><br>                newData[i] = data[i];<span class="hljs-comment">//移动数据</span><br>            &#125;<br><br>            <span class="hljs-comment">//再将需要插入的输入放入新的内存数据中</span><br>            newData[index] = elem;<br>            ++length;<span class="hljs-comment">//长度增加</span><br><br>            <span class="hljs-comment">//再次移动后面的数据</span><br>            <span class="hljs-type">size_t</span> m = <span class="hljs-number">0</span>; <br>            <span class="hljs-keyword">for</span> ( m = i; m &lt; length; m++)&#123;<br>                newData[m<span class="hljs-number">+1</span>] = data[m];<br>            &#125;<br><br>            <span class="hljs-comment">//释放原来的数据空间</span><br>            <span class="hljs-comment">//delete []data;不知道为什么，这边不能释放data。释放的话会造成严重的内存错误</span><br><br>            <span class="hljs-comment">//调整更新</span><br>            data = newData;<br>            storage = len;<br>            <span class="hljs-keyword">return</span> SUCCESS;<br>        &#125;<br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 构造一个线性表,申请内存</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">Status <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>            data = <span class="hljs-keyword">new</span> T[SIZE<span class="hljs-number">+1</span>];<span class="hljs-comment">//多申请一个空间,空余出第一个数据空间,默认大小为11</span><br>            length = <span class="hljs-number">0</span>;<span class="hljs-comment">//长度为0</span><br>            storage = SIZE;<span class="hljs-comment">//整体长度默认大小为11</span><br>            <span class="hljs-keyword">if</span> (!data)&#123;<br>                <span class="hljs-built_in">exit</span>(ERROR);<span class="hljs-comment">//如果内存申请失败，退出</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> SUCCESS;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 销毁线性表，回收内存。</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">Status <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">if</span> (!data)&#123;<br>                <span class="hljs-keyword">return</span> FAIL;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> []data;<br>            <span class="hljs-keyword">return</span> SUCCESS;<br>        &#125; <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 默认的构造函数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-built_in">List</span>()&#123;<br>           <span class="hljs-built_in">init</span>(); <br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 析构函数</span><br><span class="hljs-comment">         */</span><br>        ~<span class="hljs-built_in">List</span>()&#123;<br>            <span class="hljs-built_in">destroy</span>();<br>        &#125; <br><br>         <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在相应的位置上插入新的数据</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">Status <span class="hljs-title">insert</span><span class="hljs-params">(T elem,<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length<span class="hljs-number">+1</span> )&#123;<span class="hljs-comment">//判断下标是否合法</span><br>                <span class="hljs-keyword">return</span> ARRAY_OUT_OF_BOUNDS;<span class="hljs-comment">//返回下标越界错误</span><br>            &#125; <br>            <span class="hljs-keyword">if</span> (storage == length)&#123; <span class="hljs-comment">//判断空间是否满了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">addStorage</span>(elem,index);<br>            &#125;<br>            <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (i = length; i &gt;= index; --i)&#123;<span class="hljs-comment">//将数据往后面移动</span><br>                data[i<span class="hljs-number">+1</span>] = data[i];<span class="hljs-comment">//将数据往后移动</span><br>            &#125;<br>            data[i<span class="hljs-number">+1</span>] = elem;<span class="hljs-comment">//插入数据</span><br>            ++length;<span class="hljs-comment">//长度增加</span><br>            <span class="hljs-keyword">return</span> SUCCESS; <br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在线性表的末尾插入新的数据 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">Status <span class="hljs-title">insert</span><span class="hljs-params">(T elem)</span></span>&#123;<br>            <span class="hljs-keyword">if</span> (storage == length)&#123; <span class="hljs-comment">//判断空间是否满了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">addStorage</span>(elem,length);<br>            &#125;<br>            data[++length] = elem;<span class="hljs-comment">//放入数据</span><br>            <span class="hljs-keyword">return</span> SUCCESS;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回整体容量大小</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> storage;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 取出线性表的数据元素</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">T <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length)&#123;<br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Array out of bounds&quot;</span>);<span class="hljs-comment">//返回下标越界错误</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> data[index];<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回数据的索引下标</span><br><span class="hljs-comment">         */</span>  <br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">local</span><span class="hljs-params">(T elem)</span> </span>&#123;<br>            <span class="hljs-comment">//安排哨兵</span><br>            data[<span class="hljs-number">0</span>] = elem;<br>            <span class="hljs-type">size_t</span> i= <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(i = length;data[i]!=elem;--i);<span class="hljs-comment">//查询位置。数据相等就退出。</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//查找失败，返回-1</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回位置</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 修改指定位置的数据</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">Status <span class="hljs-title">updateIndex</span><span class="hljs-params">(T newElem,<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length )&#123;<br>                <span class="hljs-keyword">return</span> ARRAY_OUT_OF_BOUNDS;<span class="hljs-comment">//返回数组下标错误</span><br>            &#125;<br>            data[index] = newElem;<span class="hljs-comment">//修改数据</span><br>            <span class="hljs-keyword">return</span> SUCCESS;<span class="hljs-comment">//返回成功</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 修改匹配的数据</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function">Status <span class="hljs-title">update</span><span class="hljs-params">(T oldElem,T newElem)</span></span>&#123;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(oldElem);<span class="hljs-comment">//先查询老数据的位置</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">return</span> FAIL;<span class="hljs-comment">//如果没有查询到，就修改错误</span><br>            &#125;<br>            data[index] = newElem;<span class="hljs-comment">//更新数据 </span><br>            <span class="hljs-keyword">return</span> SUCCESS;<span class="hljs-comment">//返回成功</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在相应的位置上删除数据</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">Status <span class="hljs-title">removeIndex</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length )&#123;<br>                <span class="hljs-keyword">return</span> ARRAY_OUT_OF_BOUNDS;<span class="hljs-comment">//返回数组下标错误</span><br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = index; i &lt;= length; ++i)&#123;<span class="hljs-comment">//数据往前面移动，覆盖掉原来的数据</span><br>                data[i] = data[i<span class="hljs-number">+1</span>];<br>            &#125;<br>            --length;<span class="hljs-comment">//长度减一</span><br>            <span class="hljs-keyword">return</span> SUCCESS;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 移除线性表中相同的元素</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">Status <span class="hljs-title">remove</span><span class="hljs-params">(T elem)</span></span>&#123;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(elem);<span class="hljs-comment">//先查询数据的位置</span><br>            <span class="hljs-keyword">if</span>(index == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">return</span> FAIL;<span class="hljs-comment">//没有数据就返回假</span><br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = index; i &lt; length; ++i)&#123;<span class="hljs-comment">//同removeIndex()</span><br>                data[i] = data[i<span class="hljs-number">+1</span>];<br>            &#125;<br>            --length;<br>            <span class="hljs-keyword">return</span> SUCCESS;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回查找元素的直接前驱</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">T * <span class="hljs-title">prior</span><span class="hljs-params">(T elem)</span></span>&#123;<br>            <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] == elem)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//第一个元素没有直接前驱</span><br>            &#125;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(elem);<br>            <span class="hljs-keyword">if</span>(index == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//没有前驱返回空</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;data[index<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回查找元素的直接后驱</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">T * <span class="hljs-title">next</span><span class="hljs-params">(T elem)</span></span>&#123;<br>            <span class="hljs-keyword">if</span> (elem == data[length])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//最后一个数据没有</span><br>            &#125;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(elem);<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> &amp;data[index<span class="hljs-number">+1</span>];<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回线性表中元素的个数</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> length;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 将线性表重置为空表，清空所有数据</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>            length = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接长度清空即可</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 判断线性表是否为空表，如果是空表，返回true，否则返回false</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> length==<span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历线性表</span><br><span class="hljs-comment">         */</span> <br>        <span class="hljs-function">Status <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt;= length; i++)&#123;<br>                std::cout&lt;&lt;<span class="hljs-string">&quot;data[&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;]=&quot;</span>&lt;&lt;data[i]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> SUCCESS;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>STL(Standard Template Library)标准模板库中的动态顺序表:向量</p></blockquote><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>&emsp;&emsp;Vector(向量)是一个能够动态扩容的顺序容器（Sequence Container）。可以简单的认为，其就是一个动态数组。(Vector使用推荐博客:<a href="https://blog.csdn.net/qq_32172673/article/details/85127176">C++ Vector 使用说明</a>)</p><h6 id="Vector的内部结构-gcc-version-8-1-0-x86-64-win32-sjlj-rev0-Built-by-MinGW-W64-project"><a href="#Vector的内部结构-gcc-version-8-1-0-x86-64-win32-sjlj-rev0-Built-by-MinGW-W64-project" class="headerlink" title="Vector的内部结构(gcc version 8.1.0 (x86_64-win32-sjlj-rev0, Built by MinGW-W64 project)"></a>Vector的内部结构(gcc version 8.1.0 (x86_64-win32-sjlj-rev0, Built by MinGW-W64 project)</h6><p>(通过看候捷老师的《STL 源码剖析》，了解到在G2.9之前，Vector就是单独的一个类，其结构比较清晰。而到了G4.9的版本后，其结构进行了改变。复杂了。在这里先附上我看的<a href="https://www.bilibili.com/video/av59131050?p=16">STL源码解析视频链接</a>,老师讲的特别的棒！)<br><br><strong>首先，我们先了解一下vector是如何工作的。</strong><br>1.在vector中拥有3个指针。分别是_M_start、_M_finish、_M_end_of_storage。<br>2.这三个指针所占的空间是vector所占的空间。<br>3._M_start是指向第一个数据的指针。<br>4._M_finish是指向最后一个数据的下一个指针。(没有数据)<br>5._M_end_of_storage是整个容器的末尾指针。<br>6.<strong>当_M_finish &#x3D;&#x3D; _M_end_of_storage时，容器将会扩容。扩容大小是原先大小的2倍。</strong><br>7.<strong>扩容是不会在原空间上直接往后面开辟空间，而是另外寻一处空间进行存储，将原空间的数据移动过去后，释放原空间。</strong><br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/4.webp" alt="loading-ag-418"></p><p><strong>其次，Vector被分成了三个部分。_Vector_base、_Vector_impl、Vector。其中_Vector_base是一个结构体,_Vector_base的结构体中又包含着_Vector_impl：结构体,而_Vector_impl公有继承allocator分配器。最后，由Vector类保护继承_Vector_base结构体。大致如下：</strong><br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/5.webp" alt="Vector框架图"><br>**_Vector_base结构体:</p><h5 id="Vector-impl"><a href="#Vector-impl" class="headerlink" title="_Vector_impl"></a>_Vector_impl</h5><p><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/6.webp" alt="_Vector_impl"></p><h5 id="Vector-base"><a href="#Vector-base" class="headerlink" title="_Vector_base"></a>_Vector_base</h5><p>(因为_Vector_impl被_Vector_base所包含，所有该代码将会被剔除_Vector_impl部分)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<span class="hljs-comment">//数据类型为_Tp,分配器为_Alloc</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Vector_base</span><br>    &#123;<br>      <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="hljs-keyword">template</span><br>    rebind&lt;_Tp&gt;::other _Tp_alloc_type;<span class="hljs-comment">//重命名分配器为_Tp_alloc_type,其实就是allocator&lt;_Tp&gt;</span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;::pointer<br>           pointer;<span class="hljs-comment">//分配器指针</span><br>    <span class="hljs-comment">//_Vector_base的公有部分</span><br>    <span class="hljs-keyword">public</span>:<br>      <span class="hljs-keyword">typedef</span> _Alloc allocator_type;<span class="hljs-comment">//重命名分配器为allocator_type</span><br><br>      _Tp_alloc_type&amp;<span class="hljs-comment">//返回分配器的引用 _M_impl是_Vector_impl类型;</span><br>      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT<br>      &#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">static_cast</span>&lt;_Tp_alloc_type*&gt;(&amp;<span class="hljs-keyword">this</span>-&gt;_M_impl); &#125;<br><br>      <span class="hljs-type">const</span> _Tp_alloc_type&amp;<span class="hljs-comment">//返回分配器常量的引用。</span><br>      _M_get_Tp_allocator() <span class="hljs-type">const</span> _GLIBCXX_NOEXCEPT<br>      &#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> _Tp_alloc_type*&gt;(&amp;<span class="hljs-keyword">this</span>-&gt;_M_impl); &#125;<br><br>      allocator_type<span class="hljs-comment">//返回分配器的类型</span><br>      <span class="hljs-built_in">get_allocator</span>() <span class="hljs-type">const</span> _GLIBCXX_NOEXCEPT<br>      &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">allocator_type</span>(_M_get_Tp_allocator()); &#125;<br>      <span class="hljs-comment">//默认的构造函数，调用_Vector_impl的构造函数</span><br>      _Vector_base()<br>      : _M_impl() &#123; &#125;<br>      <span class="hljs-comment">//带参数的构造函数，调用_Vector_impl的带参数的构造函数，选择分配器。</span><br>      _Vector_base(<span class="hljs-type">const</span> allocator_type&amp; __a) _GLIBCXX_NOEXCEPT<br>      : _M_impl(__a) &#123; &#125;<br>      <span class="hljs-comment">//由默认分配器分配空间的的构造函数</span><br>      _Vector_base(<span class="hljs-type">size_t</span> __n)<br>      : _M_impl()<br>      &#123; _M_create_storage(__n); &#125;<br>      <span class="hljs-comment">//即由指定分配器分配空间的构造函数。</span><br>      _Vector_base(<span class="hljs-type">size_t</span> __n, <span class="hljs-type">const</span> allocator_type&amp; __a)<br>      : _M_impl(__a)<br>      &#123; _M_create_storage(__n); &#125;<br>      <span class="hljs-comment">//析构函数，释放内存。</span><br>      ~_Vector_base() _GLIBCXX_NOEXCEPT<br>      &#123;<br>    _M_deallocate(_M_impl._M_start,<br>              _M_impl._M_end_of_storage - _M_impl._M_start);<br>      &#125;<br><br>    <span class="hljs-keyword">public</span>:<br>      _Vector_impl _M_impl;<span class="hljs-comment">//_Vector_impl结构体对象 _M_impl</span><br>      <span class="hljs-comment">//分配内存函数。如果传入参数为0，就直接返回一个空的指针。否则由分配器返回一个空间大小为__n的指针</span><br>      pointer<br>      _M_allocate(<span class="hljs-type">size_t</span> __n)<br>      &#123;<br>    <span class="hljs-keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;<br>    <span class="hljs-keyword">return</span> __n != <span class="hljs-number">0</span> ? _Tr::<span class="hljs-built_in">allocate</span>(_M_impl, __n) : <span class="hljs-built_in">pointer</span>();<br>      &#125;<br>      <span class="hljs-comment">//释放内存函数。如果释放的指针__p存在，就释放。__n是其释放的空间大小。_M_impl是其释放的分配器。</span><br>     <span class="hljs-comment">//即，使用_M_impl分配器对__p释放__n个空间大小。</span><br>      <span class="hljs-type">void</span><br>      _M_deallocate(pointer __p, <span class="hljs-type">size_t</span> __n)<br>      &#123;<br>    <span class="hljs-keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;<br>    <span class="hljs-keyword">if</span> (__p)<span class="hljs-comment">//如果指针存在，就释放其指针</span><br>      _Tr::<span class="hljs-built_in">deallocate</span>(_M_impl, __p, __n);<br>      &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>      <span class="hljs-type">void</span><br>      _M_create_storage(<span class="hljs-type">size_t</span> __n)<span class="hljs-comment">//创建存储空间函数。</span><br>      &#123;<br>      <span class="hljs-comment">//申请空键给_M_start指针</span><br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start = <span class="hljs-keyword">this</span>-&gt;_M_allocate(__n);<br>      <span class="hljs-comment">//初始化时没有数据，_M_finish指针即等于_M_start指针</span><br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start;<br>    <span class="hljs-comment">//空间存储容量尾指针即开始的指针+整个容量</span><br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start + __n;<br>      &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure><h5 id="Vector-1"><a href="#Vector-1" class="headerlink" title="Vector"></a>Vector</h5><p><strong>(类的声明)</strong><br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/7.webp" alt="Vector类的声明"><br><strong>(重命名定义)</strong><br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/8.webp" alt="loading-ag-440"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">//默认的构造函数</span><br> <span class="hljs-built_in">vector</span>(): _Base() &#123; &#125;<br> <span class="hljs-comment">//指定分配器的构造函数</span><br>  <span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> allocator_type&amp; __a) _GLIBCXX_NOEXCEPT<br>  : _Base(__a) &#123; &#125;<br>  <span class="hljs-comment">//指定空间大小和分配器的构造函数</span><br>  <span class="hljs-built_in">vector</span>(size_type __n, <span class="hljs-type">const</span> allocator_type&amp; __a = <span class="hljs-built_in">allocator_type</span>())<br>  : _Base(__n, __a)<br>  &#123; _M_default_initialize(__n); &#125;<span class="hljs-comment">//使用_M_default_initialize()来初始化数据</span><br><span class="hljs-comment">/*void     _M_default_initialize()函数</span><br><span class="hljs-comment">  _M_default_initialize(size_type __n)</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">this-&gt;_M_impl._M_finish =</span><br><span class="hljs-comment">  std::__uninitialized_default_n_a(this-&gt;_M_impl._M_start, __n,</span><br><span class="hljs-comment">                   _M_get_Tp_allocator());//初始化数据</span><br><span class="hljs-comment">  &#125;*/</span><br><br> <span class="hljs-comment">//指定空间大小和默认值以及分配器</span><br>  <span class="hljs-built_in">vector</span>(size_type __n, <span class="hljs-type">const</span> value_type&amp; __value,<br>     <span class="hljs-type">const</span> allocator_type&amp; __a = <span class="hljs-built_in">allocator_type</span>())<br>  : _Base(__n, __a)<br>  &#123; _M_fill_initialize(__n, __value); &#125;<br>   <span class="hljs-comment">//指定空间大小和默认值以及分配器(默认值和分配器可以不用传入)</span><br>  <span class="hljs-built_in">vector</span>(size_type __n, <span class="hljs-type">const</span> value_type&amp; __value = <span class="hljs-built_in">value_type</span>(),<br>     <span class="hljs-type">const</span> allocator_type&amp; __a = <span class="hljs-built_in">allocator_type</span>())<br>  : _Base(__n, __a)<br>  &#123; _M_fill_initialize(__n, __value); &#125;<br>  <span class="hljs-comment">//深拷贝默认构造函数</span><br>  <span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&amp; __x)<br>  : _Base(__x.<span class="hljs-built_in">size</span>(),<br>_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))<br>  &#123;<br><span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish =<br>  std::__uninitialized_copy_a(__x.<span class="hljs-built_in">begin</span>(), __x.<span class="hljs-built_in">end</span>(),<br>                  <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start,<br>                  _M_get_Tp_allocator());<br>  &#125;<br>  <span class="hljs-comment">//双引用？？？这个不清楚。</span><br>  <span class="hljs-built_in">vector</span>(vector&amp;&amp; __x) <span class="hljs-keyword">noexcept</span><br>  : _Base(std::<span class="hljs-built_in">move</span>(__x)) &#123; &#125;<br><br>  <span class="hljs-comment">/// 带备用分配器的复制构造函数</span><br>  <span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&amp; __x, <span class="hljs-type">const</span> allocator_type&amp; __a)<br>  : _Base(__x.<span class="hljs-built_in">size</span>(), __a)<br>  &#123;<br><span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish =<br>  std::__uninitialized_copy_a(__x.<span class="hljs-built_in">begin</span>(), __x.<span class="hljs-built_in">end</span>(),<br>                  <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start,<br>                  _M_get_Tp_allocator());<br>  &#125;<br><br>  <span class="hljs-comment">/// 使用备用分配器移动构造函数</span><br>  <span class="hljs-built_in">vector</span>(vector&amp;&amp; __rv, <span class="hljs-type">const</span> allocator_type&amp; __m)<br>  <span class="hljs-built_in">noexcept</span>(_Alloc_traits::_S_always_equal())<br>  : _Base(std::<span class="hljs-built_in">move</span>(__rv), __m)<br>  &#123;<br><span class="hljs-keyword">if</span> (__rv.<span class="hljs-built_in">get_allocator</span>() != __m)<br>  &#123;<br>    <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish =<br>      std::__uninitialized_move_a(__rv.<span class="hljs-built_in">begin</span>(), __rv.<span class="hljs-built_in">end</span>(),<br>                  <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start,<br>                  _M_get_Tp_allocator());<br>    __rv.<span class="hljs-built_in">clear</span>();<br>  &#125;<br>  &#125;<br> <span class="hljs-comment">//初始化一个列表作为向量数据带有默认分配器</span><br>  <span class="hljs-built_in">vector</span>(initializer_list&lt;value_type&gt; __l,<br>     <span class="hljs-type">const</span> allocator_type&amp; __a = <span class="hljs-built_in">allocator_type</span>())<br>  : _Base(__a)<br>  &#123;<br>_M_range_initialize(__l.<span class="hljs-built_in">begin</span>(), __l.<span class="hljs-built_in">end</span>(),<br>            <span class="hljs-built_in">random_access_iterator_tag</span>());<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *dtor只删除元素，并注意如果元素本身是指针，指向内存的是没有任何接触。</span><br><span class="hljs-comment">    *管理指针是用户的责任。</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">//上面的原注释翻译过来的。这是析构函数</span><br>  ~<span class="hljs-built_in">vector</span>() _GLIBCXX_NOEXCEPT<br>  &#123;<br>std::_Destroy(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start, <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish,<br>          _M_get_Tp_allocator());<br>_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>（重要部分！！！扩容部分：只分析扩容部分算了，后面的不想分析了。有时间再分析。）</strong><br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/9.webp" alt="push_back扩容"><br>(如何定义扩容后大小的函数。)<br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95(%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8)/10.webp" alt="loading-ag-452"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">简化版扩容大小函数<br><span class="hljs-type">size_t</span> _M_check_len()<br>&#123;<br>    <span class="hljs-keyword">if</span>(max_size - <span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//没有容量了</span><br>          <span class="hljs-keyword">return</span> 错误。<br>    &#125;<br>    <span class="hljs-type">size_t</span> len  =  (<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>) ? <span class="hljs-number">2</span>*<span class="hljs-built_in">size</span>() : <span class="hljs-number">1</span>;<span class="hljs-comment">//如果size()为0，就返回1，否则就扩容两倍。</span><br>    <span class="hljs-keyword">if</span>(len &gt; max_size)<span class="hljs-comment">//如果len大于最大容量，就返回最大容量</span><br>        <span class="hljs-keyword">return</span> max_size;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><p>(如何扩容的函数?！！！！！！！我简化了。去除了Vector中不需要的成分)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp, <span class="hljs-keyword">typename</span> _Alloc&gt;<br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... _Args&gt;<br>      <span class="hljs-type">void</span><br>      vector&lt;_Tp, _Alloc&gt;::<span class="hljs-comment">//扩容函数！！注意！！在push_back()中调用的_M_realloc_insert(end(), __x);</span><br>      _M_realloc_insert(iterator __position, _Args&amp;&amp;... __args)<span class="hljs-comment">//__position为_M_finish。_Args为扩充时需要添加的函数。</span><br>    &#123;<br>      <span class="hljs-type">const</span> size_type __len =<br>    _M_check_len(<span class="hljs-built_in">size_type</span>(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;vector::_M_realloc_insert&quot;</span>);<span class="hljs-comment">//获取扩容后的大小。</span><br>      pointer __old_start = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start;<span class="hljs-comment">//保存指针</span><br>      pointer __old_finish = <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish;<span class="hljs-comment">//保存指针</span><br>      <span class="hljs-comment">//这个地方其实就是end()-begin()。其实就是size():当前容量。也就是说。__elems_before为当然容量。</span><br>      <span class="hljs-type">const</span> size_type __elems_before = __position - <span class="hljs-built_in">begin</span>();<br>      pointer __new_start(<span class="hljs-keyword">this</span>-&gt;_M_allocate(__len));<span class="hljs-comment">//分配一个新的空间</span><br>      pointer __new_finish(__new_start);<span class="hljs-comment">//这个地方其实就是_new_finish = _new_start;</span><br>      __try<br>    &#123;<br><span class="hljs-comment">//原来的注释 ： 三个操作的顺序由C++ 11决定。如果移动可以改变属于现有向量。这是一个只有来电者才有的问题使用LVREF REF元素（参见C++ 11的最后一个子弹）[关于论点的决议]）。</span><br>        <span class="hljs-comment">//初始化新空间.将新空间的数据元素设置初值为__x.</span><br>      _Alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl,<br>                   __new_start + __elems_before,<br>       <span class="hljs-meta">#<span class="hljs-keyword">if</span> __cplusplus &gt;= 201103L</span><br>                   std::forward&lt;_Args&gt;(__args)...);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                   __x);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      __new_finish = <span class="hljs-built_in">pointer</span>();<span class="hljs-comment">//将_new_finish指针重置</span><br>          <span class="hljs-comment">//将原先的数据移动到新空间来。</span><br>      __new_finish<br>        = std::__uninitialized_move_if_noexcept_a<br>        (__old_start, __position.<span class="hljs-built_in">base</span>(),<br>         __new_start, _M_get_Tp_allocator());<br>        <span class="hljs-comment">//赋值之后，数据的结尾指针++</span><br>      ++__new_finish;<br>        <span class="hljs-comment">//移动安插点后面的数据。(因为会被insert()所调用)</span><br>      <span class="hljs-comment">//当被push_back()调用时，上面的那个移动函数就已经完成了。</span><br><span class="hljs-comment">//这个是给insert()使用的。当被insert()使用时。__position就不是当前容量。而是插入点和起点的距离。</span><br><span class="hljs-comment">//届时上面是移动插入点到起点之间的数据。后面这个是移动插入点到数据终点的数据。</span><br>      __new_finish<br>        = std::__uninitialized_move_if_noexcept_a<br>        (__position.<span class="hljs-built_in">base</span>(), __old_finish,<br>         __new_finish, _M_get_Tp_allocator());<br>    &#125;<br>      __catch(...)<br>    &#123;<br>    <span class="hljs-comment">//如果失败，就回收开辟后的内存。抛出异常。</span><br>      <span class="hljs-keyword">if</span> (!__new_finish)<br>        _Alloc_traits::<span class="hljs-built_in">destroy</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl,<br>                   __new_start + __elems_before);<br>      <span class="hljs-keyword">else</span>。<br>        std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());<br>      _M_deallocate(__new_start, __len);<br>      __throw_exception_again;<br>    &#125;<br>      _GLIBCXX_ASAN_ANNOTATE_REINIT;<br>      <span class="hljs-comment">//销毁原空间。</span><br>      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());<br>      _M_deallocate(__old_start,<br>            <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage - __old_start);<br>    <span class="hljs-comment">//重新调整指针。</span><br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start = __new_start;<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish = __new_finish;<br>      <span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage = __new_start + __len;<br>    &#125;<br></code></pre></td></tr></table></figure><p>#####(部分函数)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-comment">//返回_M_start指针</span><br> <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start); &#125;<br> <span class="hljs-comment">//返回_M_finish指针</span><br> <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish); &#125;<br> <span class="hljs-comment">//通过_M_finish-_M_start得到容量大小。</span><br> <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">size_type</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_finish - <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start); &#125;<br> <span class="hljs-comment">//通过_M_end_of_storage - _M_start来得到整个容量</span><br> <span class="hljs-function">size_type <span class="hljs-title">capacity</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">size_type</span>(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_end_of_storage<br>        - <span class="hljs-keyword">this</span>-&gt;_M_impl._M_start); &#125;<br> <span class="hljs-comment">//通过_M_finish是否等于_M_start来判断是否为空</span><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() == <span class="hljs-built_in">end</span>(); &#125;<br> <span class="hljs-comment">//其实就是通过_M_start+下标长度来获取值的引用</span><br> reference <span class="hljs-keyword">operator</span>[](size_type __n)<br> &#123;<br>   __glibcxx_requires_subscript(__n);<br>   <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_M_impl._M_start + __n);<br> &#125;<br> <span class="hljs-comment">//返回_M_start值的引用</span><br> <span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">begin</span>(); &#125;<br><span class="hljs-comment">//返回_M_finish-1的引用(为什么要-1？因为_M_finish指向的空间是没有数据的。它是最后一个数据的下一个数据。所以要-1)</span><br> <span class="hljs-function">reference <span class="hljs-title">back</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *(<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>); &#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><p>&emsp;&emsp;Vector是向量。其行为像动态数组。（说动态数组好像也可以。）当我们在实现动态顺序表时，主要注意以下一点。<br> <strong>在扩容时，不能原地扩容。需要新开辟空间，再将数据转移过去。</strong><br> 另外。这是rebind分配器的一个链接。<a href="https://blog.csdn.net/tmhanks/article/details/90740914">STL源码阅读（2）–allocator::rebind</a>.</p><blockquote><p>个人后话</p></blockquote><p>&emsp;&emsp;嘛呀，终于写完了。今天卡在释放内存那边卡了4个多小时。可以说是今天写了一天了。好累啊。明天不会更新数据结构的类容。太烧脑了。看源代码也是。明天放假一天！</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表的顺序存储结构</title>
    <link href="/2020/02/03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <url>/2020/02/03/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>线性表的顺序存储结构</p></blockquote><p>&emsp;&emsp;线性表的顺序存储结构是通过一组连续的存储单元一次存储线性表的数据元素。其特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。</p><blockquote><p>数据的存储位置:</p></blockquote><ol><li><p>假设线性表的每个数据元素需要占用$x$个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储起始位置。</p></li><li><p>则线性表中第x+1个数据元素的存储位置$LOC(x+1)$和第$x$个元素的存储位置$LOC(x)$之间满足该条件：$$LOC(x+1) &#x3D; LOC(x) +1$。</p></li><li><p>一般来说，线性表的第x个数据元素的存储位置:$LOC(x) &#x3D; LOC(x)+X(x-1)$。<br><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/1.webp" alt="1"></p><blockquote><p>顺序结构的优缺点</p></blockquote></li></ol><p>&emsp;&emsp;优点:拥有随机访问的能力，依靠下标访问数据的时间复杂度为常数阶。其存储位置也可以用一个简单，直观的公式来表示。<br>&emsp;&emsp;缺点:在做插入或删除操作时，需要移动大量数据。其时间复杂度较高。且有着其长度固定的静态特点。可能会导致内存空间浪费或内存空间不够。</p><blockquote><p>顺序存储结构类实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><code class="hljs cpp">     <span class="hljs-comment">/**状态枚举定义:在记录七已经定义过了*/</span><br>     <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span>&#123;<br><br>        SUCCESS,FAIL,MEMORY_ALLOCATION_FAILED,ARRAY_OUT_OF_BOUNDS,OTHER_ERROR<br><br>        <span class="hljs-comment">/**枚举定义说明</span><br><span class="hljs-comment">         * SUCCESS:操作成功</span><br><span class="hljs-comment">         * FAIL:操作失败</span><br><span class="hljs-comment">         * MEMORY_ALLOCATION_FAILED:内存分配失败</span><br><span class="hljs-comment">         * ARRAY_OUT_OF_BOUNDS:数组下标越界</span><br><span class="hljs-comment">         * OTHER_ERROR:其它错误</span><br><span class="hljs-comment">         */</span><br>    &#125;; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *顺序存储结构类声明 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-type">size_t</span> SIZE&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderList</span> : <span class="hljs-keyword">public</span> ListSelf&lt;T&gt;&#123;<span class="hljs-comment">//OrderList : 顺序表类 继承 线性表抽象类(ListSelf) </span><br>        <span class="hljs-keyword">private</span>:<br>            T * data;<span class="hljs-comment">//数据元素首地址</span><br>            <span class="hljs-type">size_t</span> length;<span class="hljs-comment">//存储长度</span><br>        <span class="hljs-keyword">protected</span>:<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 构造一个线性表,申请内存</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function">Status <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>                data = <span class="hljs-keyword">new</span> T[SIZE<span class="hljs-number">+1</span>];<span class="hljs-comment">//多申请一个空间,空余出第一个数据空间</span><br>                length = <span class="hljs-number">0</span>;<span class="hljs-comment">//长度为0</span><br>                <span class="hljs-keyword">if</span> (!data)&#123;<br>                    <span class="hljs-built_in">exit</span>(ERROR);<span class="hljs-comment">//如果内存申请失败，退出</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> SUCCESS;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 销毁线性表，回收内存。</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">Status <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-keyword">if</span> (!data)&#123;<br>                    <span class="hljs-keyword">return</span> FAIL;<br>                &#125;<br>                <span class="hljs-keyword">delete</span> [] data;<br>                <span class="hljs-keyword">return</span> SUCCESS;<br>            &#125; <br><br>        <span class="hljs-keyword">public</span>:<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 默认的构造函数</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-built_in">OrderList</span>()&#123;<br>                <span class="hljs-built_in">init</span>();<span class="hljs-comment">//调用init()函数，构建线性表</span><br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 析构函数</span><br><span class="hljs-comment">             */</span><br>            ~<span class="hljs-built_in">OrderList</span>()&#123;<br>                <span class="hljs-built_in">destroy</span>();<span class="hljs-comment">//回收内存</span><br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 在相应的位置上插入新的数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">Status <span class="hljs-title">insert</span><span class="hljs-params">(T elem,<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>                <span class="hljs-keyword">if</span> (length == SIZE)&#123; <span class="hljs-comment">//判断满</span><br>                    <span class="hljs-keyword">return</span> FULL;<span class="hljs-comment">//返回满</span><br>                &#125;<br>                <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length<span class="hljs-number">+1</span> )&#123;<span class="hljs-comment">//判断下标是否合法</span><br>                    <span class="hljs-keyword">return</span> ARRAY_OUT_OF_BOUNDS;<span class="hljs-comment">//返回下标越界错误</span><br>                &#125; <br>                <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (i = length; i &gt;= index; --i)&#123;<span class="hljs-comment">//将数据往后面移动</span><br>                    data[i<span class="hljs-number">+1</span>] = data[i];<span class="hljs-comment">//将数据往后移动</span><br>                &#125;<br>                data[i<span class="hljs-number">+1</span>] = elem;<span class="hljs-comment">//插入数据</span><br>                ++length;<span class="hljs-comment">//长度增加</span><br>                <span class="hljs-keyword">return</span> SUCCESS; <br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 在线性表的末尾插入新的数据 </span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function">Status <span class="hljs-title">insert</span><span class="hljs-params">(T elem)</span></span>&#123;<br>                <span class="hljs-keyword">if</span> (length == SIZE)&#123;<span class="hljs-comment">//判断是否空间是否为满</span><br>                    <span class="hljs-keyword">return</span> FULL;<br>                &#125;<br>                data[++length] = elem;<span class="hljs-comment">//放入数据</span><br>                <span class="hljs-keyword">return</span> SUCCESS;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 取出线性表的数据元素</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">T <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>                <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length)&#123;<br>                    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Array out of bounds&quot;</span>);<span class="hljs-comment">//返回下标越界错误</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> data[index];<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回数据的索引下标</span><br><span class="hljs-comment">             */</span>  <br>            <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">local</span><span class="hljs-params">(T elem)</span> </span>&#123;<br>                <span class="hljs-comment">//安排哨兵</span><br>                data[<span class="hljs-number">0</span>] = elem;<br>                <span class="hljs-type">size_t</span> i= <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(i = length;data[i]!=elem;--i);<span class="hljs-comment">//查询位置。数据相等就退出。</span><br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//查找失败，返回-1</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//返回位置</span><br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 修改指定位置的数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">Status <span class="hljs-title">updateIndex</span><span class="hljs-params">(T newElem,<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>                <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length )&#123;<br>                    <span class="hljs-keyword">return</span> ARRAY_OUT_OF_BOUNDS;<span class="hljs-comment">//返回数组下标错误</span><br>                &#125;<br>                data[index] = newElem;<span class="hljs-comment">//修改数据</span><br>                <span class="hljs-keyword">return</span> SUCCESS;<span class="hljs-comment">//返回成功</span><br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 修改匹配的数据</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function">Status <span class="hljs-title">update</span><span class="hljs-params">(T oldElem,T newElem)</span></span>&#123;<br>                <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(oldElem);<span class="hljs-comment">//先查询老数据的位置</span><br>                <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> FAIL;<span class="hljs-comment">//如果没有查询到，就修改错误</span><br>                &#125;<br>                data[index] = newElem;<span class="hljs-comment">//更新数据 </span><br>                <span class="hljs-keyword">return</span> SUCCESS;<span class="hljs-comment">//返回成功</span><br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 在相应的位置上删除数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">Status <span class="hljs-title">removeIndex</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span></span>&#123;<br>                <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">1</span> || index &gt; length )&#123;<br>                    <span class="hljs-keyword">return</span> ARRAY_OUT_OF_BOUNDS;<span class="hljs-comment">//返回数组下标错误</span><br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = index; i &lt;= length; ++i)&#123;<span class="hljs-comment">//数据往前面移动，覆盖掉原来的数据</span><br>                    data[i] = data[i<span class="hljs-number">+1</span>];<br>                &#125;<br>                --length;<span class="hljs-comment">//长度减一</span><br>                <span class="hljs-keyword">return</span> SUCCESS;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 移除线性表中相同的元素</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">Status <span class="hljs-title">remove</span><span class="hljs-params">(T elem)</span></span>&#123;<br>                <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(elem);<span class="hljs-comment">//先查询数据的位置</span><br>                <span class="hljs-keyword">if</span>(index == <span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> FAIL;<span class="hljs-comment">//没有数据就返回假</span><br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = index; i &lt; length; ++i)&#123;<span class="hljs-comment">//同removeIndex()</span><br>                    data[i] = data[i<span class="hljs-number">+1</span>];<br>                &#125;<br>                --length;<br>                <span class="hljs-keyword">return</span> SUCCESS;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回查找元素的直接前驱</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">T * <span class="hljs-title">prior</span><span class="hljs-params">(T elem)</span></span>&#123;<br>                <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] == elem)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//第一个元素没有直接前驱</span><br>                &#125;<br>                <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(elem);<br>                <span class="hljs-keyword">if</span>(index == <span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//没有前驱返回空</span><br>                &#125;<br>                <span class="hljs-keyword">return</span> &amp;data[index<span class="hljs-number">-1</span>];<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回查找元素的直接后驱</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">T * <span class="hljs-title">next</span><span class="hljs-params">(T elem)</span></span>&#123;<br>                <span class="hljs-keyword">if</span> (elem == data[length])&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//最后一个数据没有</span><br>                &#125;<br>                <span class="hljs-type">int</span> index = <span class="hljs-built_in">local</span>(elem);<br>                <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> &amp;data[index<span class="hljs-number">+1</span>];<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回线性表中元素的个数</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-keyword">return</span> length;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 将线性表重置为空表，清空所有数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>                length = <span class="hljs-number">0</span>;<span class="hljs-comment">//直接长度清空即可</span><br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 判断线性表是否为空表，如果是空表，返回true，否则返回false</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-keyword">return</span> length==<span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 遍历线性表</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function">Status <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt;= length; i++)&#123;<br>                    std::cout&lt;&lt;<span class="hljs-string">&quot;data[&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;]=&quot;</span>&lt;&lt;data[i]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> SUCCESS;<br>            &#125;<br><br>    &#125;;<span class="hljs-comment">//顺序存储结构类结束</span><br></code></pre></td></tr></table></figure><blockquote><p>STL(Standard Template Library)标准模板库中的顺序表</p></blockquote><blockquote><p>Array</p></blockquote><p>Array是C++11新添加的一种容器。是一种固定大小的容器。容器中包含着以严格的线性序列的排列的数据元素。  并且不通过分配器管理其内存的分配。其编译是常数阶，没有格外的内存和时间开销。</p><p>(Array的使用推荐博客:<a href="https://blog.csdn.net/zhengqijun_/article/details/81566109#%EF%BC%881%EF%BC%89">c++ array模板类使用</a>,这里是分析源码。)</p><p>Array源码分析(gcc version 8.1.0 (x86_64-win32-sjlj-rev0, Built by MinGW-W64 project)</p><p>(我是直接从里面拷出来看的&#x3D;-&#x3D;)</p><p>__array_traits结构体,是作为存储用的。Array的底层依旧是一个数组。</p><p><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/2.webp"></p><p>当Array的大小为O时，底层是一个空的结构体。</p><p><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/3.webp" alt="3"></p><p>Array是一个结构体。里面重命名了大量的数据类型。</p><p><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/4.webp" alt="4"></p><blockquote><p>fill函数实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; __u)</span></span><br><span class="hljs-function"></span>&#123; std::<span class="hljs-built_in">fill_n</span>(<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">size</span>(), __u); &#125;<span class="hljs-comment">//调用了fill_n的函数</span><br><span class="hljs-comment">//fill_n函数:https://www.cnblogs.com/Emilylice/p/7754700.html</span><br></code></pre></td></tr></table></figure><blockquote><p> swap函数实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">      <span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function">      <span class="hljs-title">swap</span><span class="hljs-params">(array&amp; __other)</span></span><br><span class="hljs-function">      <span class="hljs-title">noexcept</span><span class="hljs-params">(_AT_Type::_Is_nothrow_swappable::value)</span></span><br><span class="hljs-function">      </span>&#123; std::<span class="hljs-built_in">swap_ranges</span>(<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">end</span>(), __other.<span class="hljs-built_in">begin</span>()); &#125;<span class="hljs-comment">//调用了swap_ranges函数。</span><br><br><span class="hljs-function">swap_ranges</span><br><span class="hljs-function">      <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _ForwardIterator1, <span class="hljs-keyword">typename</span> _ForwardIterator2&gt;</span><br><span class="hljs-function">        _ForwardIterator2</span><br><span class="hljs-function">        <span class="hljs-title">swap_ranges</span><span class="hljs-params">(_ForwardIterator1 __first1, _ForwardIterator1 __last1,</span></span><br><span class="hljs-params"><span class="hljs-function">        _ForwardIterator2 __first2)</span></span><br><span class="hljs-function">      </span>&#123;<br>      <span class="hljs-comment">// concept requirements</span><br>      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<br>                  _ForwardIterator1&gt;)<br>      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept&lt;<br>                  _ForwardIterator2&gt;)<br>      __glibcxx_requires_valid_range(__first1, __last1);<br><br>      <span class="hljs-keyword">for</span> (; __first1 != __last1; ++__first1, (<span class="hljs-type">void</span>)++__first2)<br>    std::<span class="hljs-built_in">iter_swap</span>(__first1, __first2);<span class="hljs-comment">//实践上是遍历原迭代器，然后交换值。</span><br>      <span class="hljs-keyword">return</span> __first2;<span class="hljs-comment">//返回交换后的数据</span><br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>data函数的实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">_GLIBCXX17_CONSTEXPR pointer</span><br><span class="hljs-function"><span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> _AT_Type::_S_ptr(_M_elems); &#125;<span class="hljs-comment">//直接调用__array_traits结构体中的指针函数。</span><br>  <span class="hljs-comment">//取出当前指针。_M_elems是底层的数组或者空结构体。</span><br><br><span class="hljs-function">_GLIBCXX17_CONSTEXPR const_pointer</span><br><span class="hljs-function"><span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span><span class="hljs-comment">//返回常量的data()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> _AT_Type::_S_ptr(_M_elems); &#125;<br></code></pre></td></tr></table></figure><blockquote><p>begin,end等迭代器实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Iterators.</span><br>      <span class="hljs-function">_GLIBCXX17_CONSTEXPR iterator</span><br><span class="hljs-function">      <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-built_in">data</span>()); &#125; <span class="hljs-comment">//调用data(),将其转换为数据类型的指针。</span><br><span class="hljs-comment">//=-=假设我们是array&lt;int,10&gt;。那么T就是int类型的。data()返回的就是int *的。然后再转为int *类型，</span><br><span class="hljs-comment">//emmm，我测试了一下，好像也是int *；好像是强制转换了T *类型的了。</span><br><br>      <span class="hljs-function">_GLIBCXX17_CONSTEXPR const_iterator</span><br><span class="hljs-function">      <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(<span class="hljs-built_in">data</span>()); &#125;<br><br>      <span class="hljs-function">_GLIBCXX17_CONSTEXPR iterator</span><br><span class="hljs-function">      <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(<span class="hljs-built_in">data</span>() + _Nm); &#125;<span class="hljs-comment">//end()函数则是调用data()取得底层数组的首地址。</span><br><span class="hljs-comment">//然后再加上长度。返回就是尾部地址。然后再转换一下。就得到T *了。</span><br>(需要注意的是！！<span class="hljs-built_in">data</span>()+_Nm后，其地址不包含了数据了。也就是<span class="hljs-built_in">data</span>()+_Nm<span class="hljs-number">-1</span>才是最后的尾数据。)<br><br>      <span class="hljs-function">_GLIBCXX17_CONSTEXPR const_iterator</span><br><span class="hljs-function">      <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_iterator</span>(<span class="hljs-built_in">data</span>() + _Nm); &#125;<br></code></pre></td></tr></table></figure><blockquote><p>at,front,back等取值函数的实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****************************************at()******************************/</span><br>(首先是传入了下标，然后利用三元运算法，将下标和数组长度进行比较。<br>如果传入的下标比数组长度要长度要小，就调用__array_traits结构体中引用函数,返回其数据的引用。<br>否则，抛出异常。)<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> const_reference</span><br><span class="hljs-function">      <span class="hljs-title">at</span><span class="hljs-params">(size_type __n)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">      </span>&#123;<br>    <span class="hljs-comment">// Result of conditional expression must be an lvalue so use</span><br>    <span class="hljs-comment">// boolean ? lvalue : (throw-expr, lvalue)</span><br>    <span class="hljs-keyword">return</span> __n &lt; _Nm ? _AT_Type::_S_ref(_M_elems, __n)<br>      : (std::__throw_out_of_range_fmt(__N(<span class="hljs-string">&quot;array::at: __n (which is %zu) &quot;</span><br>                           <span class="hljs-string">&quot;&gt;= _Nm (which is %zu)&quot;</span>),<br>                       __n, _Nm),<br>         _AT_Type::_S_ref(_M_elems, <span class="hljs-number">0</span>));<br>      &#125;<br><span class="hljs-comment">/*****************************************front()******************************/</span><br>      <span class="hljs-function">_GLIBCXX17_CONSTEXPR reference</span><br><span class="hljs-function">      <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> *<span class="hljs-built_in">begin</span>(); &#125;<span class="hljs-comment">//直接调用begin().*begin()就是直接返回值。</span><br><span class="hljs-comment">//而reference是数据的引用。所有front()其实就是返回数据的引用。</span><br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> const_reference</span><br><span class="hljs-function">      <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> _AT_Type::_S_ref(_M_elems, <span class="hljs-number">0</span>); &#125;<span class="hljs-comment">//如果返回的是一个常量的话，</span><br><span class="hljs-comment">//是直接调用__array_traits结构体中引用函数返回的。</span><br><span class="hljs-comment">/*****************************************back()******************************/</span><br>      <span class="hljs-function">_GLIBCXX17_CONSTEXPR reference</span><br><span class="hljs-function">      <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123; <span class="hljs-keyword">return</span> _Nm ? *(<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>) : *<span class="hljs-built_in">end</span>(); &#125;<span class="hljs-comment">//这是一个三元运算符。如果你给array的长度为0的话，</span><br><span class="hljs-comment">//就直接返回end()的值。我测试了一下，    array&lt;int,0&gt; arr;cout&lt;&lt;arr.end()&lt;&lt;endl;输出的0</span><br><span class="hljs-comment">//.至于为什么。有点搞不懂。</span><br><span class="hljs-comment">//长度不为0，就返回最后一个数据的引用。end()返回的不是最后的数据，而是最后一个数据后的下一个地址。</span><br><br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> const_reference</span><br><span class="hljs-function">      <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">      </span>&#123;<br>    <span class="hljs-keyword">return</span> _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - <span class="hljs-number">1</span>)<br>               : _AT_Type::_S_ref(_M_elems, <span class="hljs-number">0</span>);<br>      &#125;<br></code></pre></td></tr></table></figure><blockquote><p>size,max_size,empty等函数的实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****************************************size()******************************/</span><br>      <span class="hljs-comment">// Capacity.</span><br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> size_type</span><br><span class="hljs-function">      <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> _Nm; &#125;<span class="hljs-comment">//直接返回定义的大小。</span><br><span class="hljs-comment">//所以，size()不是返回当前使用的数据元素长度。</span><br><span class="hljs-comment">/*****************************************max_size()******************************/</span><br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> size_type</span><br><span class="hljs-function">      <span class="hljs-title">max_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> _Nm; &#125;<span class="hljs-comment">//和size一样的。</span><br><span class="hljs-comment">/*****************************************empty()******************************/</span><br>      <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span></span><br><span class="hljs-function">      <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//这个，只有你定义的长度不是0的话。</span><br><span class="hljs-comment">//这个就是恒定为假了。哪怕你没有使用。</span><br></code></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><p>顺序表其实和数组并没有太多的差异。我们其实完全可以使用数组来完成顺序表的功能。但是，依旧推荐Array容器来代替数组。因为其用有迭代器以及at()等方法。比数组更加安全，也更加方便。需要注意的是，Array是C++11新添的。所以需要C++11版本及其以下版本。</p><blockquote><p>个人后话</p></blockquote><p>第一次看源码，&#x3D;-&#x3D;还有点看不懂呀。但是我会坚持下去。本来今天打算把动态顺序表也一起放进去的。可是，已经晚上9点了。。。。还是算了(明天再放吧)。本来昨天还说晚上不写代码的。结果还是写了。完蛋了。</p><blockquote><p>修改</p></blockquote><p>2020年2月4日 忘记了size_t是不可能有负数的去了，在申请内存那个地方不需要判断是否为小于零，而且小于零也写错了。&#x3D;-&#x3D;太不应该了。并且考虑到因为是泛型编程GP。不应该在抽象类中使用sort的。因为如果T是一个类的对象，那么又该怎么排序呢？所以在代码中去掉了sort()函数。且<a href="https://lqzhi.github.io/2020/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</a>中的顺序结构抽象类会去掉sort()函数。在此声明。</p><p><strong>修改前的代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 构造一个线性表,申请内存</span><br><span class="hljs-comment">            */</span><br>           <span class="hljs-function">Status <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>               <span class="hljs-keyword">if</span> (SIZE &lt; <span class="hljs-number">0</span>)&#123;<br>                   data = <span class="hljs-keyword">new</span> T[SIZE<span class="hljs-number">+1</span>];<span class="hljs-comment">//多申请一个空间,空余出第一个数据空间</span><br>               &#125;<br>               data = <span class="hljs-keyword">new</span> T[SIZE<span class="hljs-number">+1</span>];<span class="hljs-comment">//多申请一个空间,空余出第一个数据空间</span><br>               length = <span class="hljs-number">0</span>;<span class="hljs-comment">//长度为0</span><br>               <span class="hljs-keyword">if</span> (!data)&#123;<br>                   <span class="hljs-built_in">exit</span>(ERROR);<span class="hljs-comment">//如果内存申请失败，退出</span><br>               &#125;<br>               <span class="hljs-keyword">return</span> SUCCESS;<br>           &#125;<br></code></pre></td></tr></table></figure><p><strong>修改后的代码:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造一个线性表,申请内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Status <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    data = <span class="hljs-keyword">new</span> T[SIZE<span class="hljs-number">+1</span>];<span class="hljs-comment">//多申请一个空间,空余出第一个数据空间</span><br>    length = <span class="hljs-number">0</span>;<span class="hljs-comment">//长度为0</span><br>    <span class="hljs-keyword">if</span> (!data)&#123;<br>        <span class="hljs-built_in">exit</span>(ERROR);<span class="hljs-comment">//如果内存申请失败，退出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2020/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2020/02/02/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p></blockquote><p>&emsp;&emsp;线性表是属于线性结构，线性结构的基本特点是除第一个元素无直接前驱，最后一个无直接后继之外，其他的每个数据元素都有一个前驱和后继。</p><blockquote><p>线性表是什么？</p></blockquote><p>&emsp;&emsp;线性表是最基本且最常用的一种线性结构。同时也是其他数据结构的基础。</p><p>&emsp;&emsp;<strong>线性表(Linear List):全称线性存储结构，其数据元素之间的关系是 一对一   的关系。即除第一个元素无直接前驱，最后一个无直接后继之外，其他的每个数据元素都有一个前驱和后继。</strong></p><blockquote><p>如何理解在内存中的线性表</p></blockquote><p>&emsp;&emsp;在内存中的线性表，我们可以简单的理解为一根绳子，将所有的数据按顺序全部都串在一起了。<br>&emsp;&emsp;而绳子的头部就是线性表的第一个元素，绳子的尾部为线性表的最后一个元素。</p><p>在<a href="https://lqzhi.github.io/2020/01/31/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">初识数据结构</a>中,谈到了数据的存储结构分为了顺序存储结构和链式存储结构。下面，我们用这两种结构去了解一下。</p><p>&emsp;&emsp;顺序存储结构：一片连续的空间，数据依次存储在空间中，空间内存地址逐渐增大。这种存储结构称为顺序存储结构，简称顺序表。</p><p><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8/1.webp"></p><p>&emsp;&emsp;链式存储结构: 空间不连续，数据通过媒介来找到下一个数据。空间的内存地址是随机分配的。但通常内存地址也是增大的。这种存储结构称为链式存储结构，简称链表。</p><p><img src="/img/docs/%E7%BA%BF%E6%80%A7%E8%A1%A8/2.webp"></p><blockquote><p>线性表的抽象数据类(C++)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> list&#123;<span class="hljs-comment">//线性表命名空间</span><br><br>    <span class="hljs-comment">/**状态枚举定义**/</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span>&#123;<br><br>        SUCCESS,FAIL,MEMORY_ALLOCATION_FAILED,ARRAY_OUT_OF_BOUNDS,OTHER_ERROR<br><br>        <span class="hljs-comment">/**枚举定义说明</span><br><span class="hljs-comment">         * SUCCESS:操作成功</span><br><span class="hljs-comment">         * FAIL:操作失败</span><br><span class="hljs-comment">         * MEMORY_ALLOCATION_FAILED:内存分配失败</span><br><span class="hljs-comment">         * ARRAY_OUT_OF_BOUNDS:数组下标越界</span><br><span class="hljs-comment">         * OTHER_ERROR:其它错误</span><br><span class="hljs-comment">         */</span><br>    &#125;; <br><br>    <span class="hljs-comment">/**顺序表抽象数据类型定义**/</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;   <span class="hljs-comment">//模板</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListSelf</span><br>    &#123;<br>        <span class="hljs-keyword">protected</span>:<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 构造一个顺序表,动态申请内存。</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 销毁顺序表，回收内存。</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span>:    <br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 在相应的位置上插入新的数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">insert</span><span class="hljs-params">(T elem,<span class="hljs-type">size_t</span> index)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 在线性表的末尾插入新的数据 </span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">insert</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 取出线性表的数据元素</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回数据的索引下标</span><br><span class="hljs-comment">             */</span>  <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">local</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 修改指定位置的数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">updateIndex</span><span class="hljs-params">(T newElem,<span class="hljs-type">size_t</span> index)</span></span>=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 修改匹配的数据</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">update</span><span class="hljs-params">(T oldElem,T newElem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 在相应的位置上删除数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">removeIndex</span><span class="hljs-params">(<span class="hljs-type">size_t</span> index)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 移除线性表中相同的元素</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">remove</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回查找元素的直接前驱</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> T * <span class="hljs-title">prior</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回查找元素的直接后驱</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> T * <span class="hljs-title">next</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>; <br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回线性表中元素的个数</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 将线性表重置为空表，清空所有数据</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 判断线性表是否为空表，如果是空表，返回true，否则返回false</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 遍历线性表</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>    &#125;;  <span class="hljs-comment">//抽象类结束</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 链式存储结构抽象类</span><br><span class="hljs-comment">     */</span> <br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkSelf</span>&#123;<br>        <span class="hljs-keyword">protected</span>:<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 构造一个链表头</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 销毁链表，回收内存。</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 向链表中添加数据</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">add</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 修改链表中的数据</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">update</span><span class="hljs-params">(T oldElem,T newElem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 删除链表中的数据</span><br><span class="hljs-comment">             */</span>  <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">remove</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 链表中结点的个数</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回查询结点的上一个结点的指针</span><br><span class="hljs-comment">             */</span> <br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> T * <span class="hljs-title">prior</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 返回查询结点的下一个结点的指针 </span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-function"><span class="hljs-keyword">virtual</span> T * <span class="hljs-title">next</span><span class="hljs-params">(T elem)</span> </span>= <span class="hljs-number">0</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 返回头指针</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-function"><span class="hljs-keyword">virtual</span> T * <span class="hljs-title">header</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 返回尾部指针</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-function"><span class="hljs-keyword">virtual</span> T * <span class="hljs-title">tail</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 为链表进行排序</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">sort</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 清空链表</span><br><span class="hljs-comment">              */</span><br>             <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>             <span class="hljs-comment">/**</span><br><span class="hljs-comment">              * 遍历整个链表</span><br><span class="hljs-comment">              */</span><br>            <span class="hljs-function"><span class="hljs-keyword">virtual</span> Status <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;      <br>    &#125;;<span class="hljs-comment">//链式存储结构抽象类结束</span><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *顺序存储结构类 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-type">size_t</span> SIZE&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderList</span> : <span class="hljs-keyword">public</span> ListSelf&lt;T&gt;&#123;<span class="hljs-comment">//OrderList : 顺序表类 继承 线性表抽象类(ListSelf) </span><br>    &#125;;<span class="hljs-comment">//顺序存储结构类结束</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *链式存储结构类 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> : <span class="hljs-keyword">public</span> LinkSelf&lt;T&gt;&#123;<span class="hljs-comment">//LinkedList : 单链表类 继承 链表抽象类(LinkSelf)</span><br>    &#125;;<span class="hljs-comment">//链式存储结构类结束</span><br><br>&#125;<span class="hljs-comment">//命名空间结束</span><br></code></pre></td></tr></table></figure><blockquote><p>线性表还没有结束</p></blockquote><p>(emmmm，很尴尬的一件事情。我觉得我不能在晚上学习。因为我发现我在晚上学习，我会失眠。大脑里面想了许许多多的东西。大部分都是关于程序的。所以，我决定晚上不写了。)</p><p>(有没有发现今天的字数特别少。是的。因为我昨天晚上4点睡得。6点自己就起床了。昨天晚上只睡了两个小时。看了几个小时的STL源码解析。想要在看看大神们是如何实现数据结构的。为了自己的狗命。晚上还是少敲代码。。)</p><p>(明天再写吧。明天应该最主要的应该是顺序结构的实现。明天是要码代码的哦。)</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度和空间复杂度</title>
    <link href="/2020/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2020/02/01/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><strong>一个算法的优劣性主要是从时间复杂度和空间复杂度进行衡量的。</strong></p><blockquote><p>时间复杂度的概念</p></blockquote><p>（下面将会以概念和大量习题了解时间复杂度。）       </p><p>         在计算机科学中，时间复杂性，又称时间复杂度，<strong>算法的时间复杂度是一个函数</strong>，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。<strong>时间复杂度常用大$O$符号表述</strong>，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。【1】</p><p>        时间复杂度定性的描述着算法的运行时间，但是时间复杂度的计算并不是运行的具体时间，而是算法执行语句的时间。一个算法的执行时间大致上等于其所以语句执行时间的总和，而语句的执行时间则为该条语句的重复次数和执行一次所需时间的乘积。【3】</p><p>        通常，我们为了计算时间复杂度，会估计算法的操作单元数量，每个单元运行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。但是，相同大小的不同输入值依旧可能会造成算法的运行时间不同，因此，我们通常在计算时间复杂度时，通常使用算法的最坏情况复杂度。记为$ T(n) $,定义为任何大小的输入<em>n</em>所需的最大运行时间。另一种较少使用的方法是平均情况复杂度，通常有特别指定才会使用。时间复杂度可以根据$T(n)$的不同，可以分为<strong>线性时间算法</strong>和<strong>指数时间算法。</strong>【1】</p><p>            一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为$ T(n)$。</p><p><strong>语句频度(Frequency Count,又称时间频度)：一条语句的重复执行次数。</strong></p><p><strong>(下面分析什么是时间复杂度)</strong></p><p>        在衡量算法效率的方法中我们知道，有<strong>事后统计算法</strong>和<strong>事前分析估计法</strong>。事后统计算法是直接用程序进行测试衡量，而事前分析估计法则是利用统计学的方法进行估计。实际上，我们是无法得到一个算法运行的绝对时间。我们只能估计其算法所需要的时间。因为程序语句在执行时，其执行时间受到软、硬件环境等影响较大。我们无法精确得出算法实际执行所需要的时间。<strong>所以，所谓的算法分析并非精确统计算法实际执行所需的时间，而是针对算法语句的执行次数做出统计，从中得到算法执行时间的信息。【3】</strong></p><p>举个例子：</p><p>（例题1.）求以下算法的执行时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)         <span class="hljs-comment">//外循环</span><br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)     <span class="hljs-comment">//内循环</span><br>           a[i][j]=<span class="hljs-number">0</span>;     <span class="hljs-comment">//执行的语句</span><br></code></pre></td></tr></table></figure><p>如何求解呢？</p><p>我们<strong>先设算法的每条语句在执行一次所需要的时间均为单位时间</strong>。单位时间为1；</p><p>则<strong>再计算语句频度</strong>。首先外循环将会执行n+1次，而内循环因为受到外循环的影响，内循环所执行的次数就是$n(n+1)$而执行的语句中，受到内外两重循环的影响，其执行的语句所执行的次数就是$n^2$。</p><p>则该算法的语句频度就为：(频度指该条语句所执行的次数。)   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)     <span class="hljs-comment">//频度为  n+1</span><br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++) <span class="hljs-comment">//频度为  n(n+1)</span><br>        a[i][j]=<span class="hljs-number">0</span>;    <span class="hljs-comment">//频度   n^2</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;因为 <strong>一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行从次数和执行一次所需时间的乘积。【3】</strong></p><p>所以，当我们提前假设每条语句执行一次所需的时间为单位时间时，算法的执行时间其实大致上就为其所以频率之和。所以，该算法的所执行时间为为$(n+1)+n(n+1)+n^2 $。为$f(n)&#x3D;2n^2+2n+1 $。</p><p>&emsp;&emsp;是不是很麻烦？我们要统计所有的语句频率才可以计算的算法的大致时间。而且，当我们计算出来后，大部分都是一些复杂的多项式。而我们要比较两个复杂的多项式的大小时，还需要计算。这样会十分麻烦。所以为了更加直白的比较两个算法运算时间。所以，<strong>我们通常只用算法中的“基本语句”的执行次数来度量算法的工作量。（“基本语句”：指算法中重复执行次数和算法的执行时间成正比的语句。它对算法的运行时间的贡献最大。）</strong></p><p>&emsp;&emsp;通常而言，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需要考虑其随问题规模增长的趋势即可。所以，我们为了考虑算法在执行的最坏的情况。我们通常将问题规模趋向于无穷。这时候，我们只需要考虑算法中基本语句的执行次数在渐进意义下的阶。</p><p>例如，在例题1中，当$n$趋向于无穷大时，显然有 $\lim_{n\to0} f(n)&#x2F;n^2 &#x3D; \lim_{n\to0} (2n^2+2n+1)&#x2F;n^2&#x3D;2  $。即即当$n$无穷大时，$f(n)$ 与$n^2$之比为一个不为零常数。即表明$f(n)$和$n^2$的数量级（Order of Magnitude）相同。我们使用</p><p>“$O$ ”表示数量级。则$T(n)&#x3D;O(f(n))&#x3D;O(n^2)$。由此可得时间复杂度的定义。</p><blockquote><p>时间复杂度的定义</p></blockquote><p><strong>一般情况下，算法中基本语句重复执行的次数是问题规模$n$的某个函数$f(n)$,算法的时间量度记作</strong></p><p>$T(n)&#x3D;O(f(n))$</p><p><strong>它表示随问题规模$n$的增大，算法执行时间的增长率和的增长率相同，称作为算法的渐进时间复杂度，简称时间复杂度（Time Complexity）。【3】</strong></p><p><strong>数学符号$O$的严格定义为：</strong></p><p><strong>若$T(n)$和$f(n)$是定义正整数集合上的两个函数，则$T(n)&#x3D;O(f(n))$表示存在正的常数$C$和$n_{0} $,使得当$n\geq n_{0} $时都满足$0\leq T(n)\leq Cf(n)$ 。【3】</strong></p><p><strong>数学符号$O$的定义说明了函数$T(n)$和$f(n)$具有相同的增长趋势，且$T(n)$的增长至多趋向于函数$f(n)$的增长。</strong></p><blockquote><p>时间复杂度个人理解（如果不对，请大佬指出。） </p></blockquote><ol><li><p>一个算法的执行时间大致上是所有语句执行时间的总和。而语句的执行时间则为该条语句重复执行次数和执行一次所需要的乘积。</p></li><li><p>一条语句的重复执行次数称作语句频度。</p></li><li><p>当设每条语句执行一次所需的时间为单位时间时，该语句的执行时间就是语句频度。</p></li><li><p>在3条的基础上可以得出该算法的执行时间是语句频度之和。</p></li><li><p>因为对于一个算法而言，语句频度是比较难以计算的。而且由语句频度得出来算法的执行时间也是不好比较的。因为都是一些复杂的多项式。</p></li><li><p>为了解决5的问题，我们只需要客观的反应算法的时间复杂度即可。而我们只需要选择一些“基本语句”，这些“基本语句”是指那些对算法的运行时间贡献最大的。对算法的运行时间是不良影响，但是却无可避免。</p></li><li><p>当我们去除一些多余的频度之后，算法的执行时间很大部分上依旧还是一些比较复杂的多项式，所以，我们还得继续简化。我们知道，在一般情况下，算法的执行时间是随则问题规模$(n)$的增长而增长的。所以，我们得从问题规模$(n)$出发。</p></li><li><p>因为问题规模$(n)$的增长，算法的执行时间对增加，所以，我们可以考虑算法的最坏情况，也就是当问题规模$(n)$无限大时，我们只需要考虑算法中基本语句的执行次数的时间在渐进意义下的阶。(什么意思呢，当执行次数为$f(n)&#x3D;n^2+2n+1$时，随着n的增大，对$f(n)$的影响最大的是$n^2$,所以我们只需要关心阶数即可。</p></li><li><p>当问题规模$n$无穷大时，我们可以用数学的极限知识，了解到，当$n$在趋向于无穷时，执行时间$f(n)$与最高阶的数量级是相同的。而数量级我们用$O$表示。所以我们在比较两个算法的执行时间时，我们可以用数量级$O$来比较。</p></li><li><p>时间复杂度的表示算法为$O$(频度)</p></li></ol><blockquote><p>求解算法的时间复杂度</p></blockquote><p>求解算法的时间复杂度之前，我们先了解一些常用的时间复杂度。</p><p>常数阶$O(1)$</p><p>对数阶$O(\log_2 n )$</p><p>线性阶$O(n)$</p><p>线性对数阶$O(n\log_2 n )$</p><p>平方阶$O(n^2)$</p><p>立方阶$O(n^3)$</p><p>K次方阶$O(n^k)(K&gt;3)$</p><p>指数阶$O(2^n)$</p><p>从上至下，随着n的不断增大，时间复杂度越大，运算所耗费的时间就越高。</p><p>计算时间复杂度主要有四步：</p><ol><li><p>求出“基本语句”所需要的频数之和。（$f(n)$）。</p></li><li><p>只保留最高次项.例如$f(n)&#x3D;3n^3+2n+1$变成$f(n)&#x3D;3n^3$。</p></li><li><p>将最高项系数都化为$1$.例如$f(n)&#x3D;3n^3$变成$f(n)&#x3D;n^3$。(注意：如果只留下了常数的话，其时间复杂度就为$O(1)$。)</p></li><li><p>代入公式$T(n)&#x3D;O(f(n))$中。例如：$f(n)&#x3D;n^3$带入公式得$T(n)&#x3D;O(n^3)$。即时间复杂度为$O(n^3)$。</p></li></ol><p>(例题在总结中。)</p><p>最好，最坏和平均时间复杂度</p><p>对于某些问题的算法，其基本语句的频度不仅仅与问题的规模相关，还依赖与其它因素。</p><p>举个例子：【3】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)                     <span class="hljs-comment">//语句1</span><br>       <span class="hljs-keyword">if</span> (a[i] == e)    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>; <span class="hljs-comment">//语句2</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                            <span class="hljs-comment">//语句3</span><br></code></pre></td></tr></table></figure><p>首先，我们可以看出，在这个算法中，语句2的频度不仅仅与问题规模$n$有关，还与实例数组$a$的各个元素值以及$e$的取值有关。</p><p>假设$a[0]&#x3D;&#x3D;e$,则时间复杂度为$O(1)$。</p><p>假设数组$a$中没有任何一个数与$e$相等，则时间复杂度为$O(n)$。</p><p>这时候，便有了一个最好时间复杂度和一个最坏时间复杂度。</p><p>而对于一个算法来说，需要考虑各种可能的出现的情况，以及每一种情况出现的概率。所以，在一般情况下，可以假设查找的元素在数组中所以位置上出现的可能性均相同。这时可以取最好情况和最坏情况的平均值。即$O(\frac{n}{2} )$。即为平均时间复杂度。</p><p>称算法在最好情况下的时间复杂度为最好的时间复杂度，指算法计算量可能达到的最小值；称算法在最坏情况下的时间复杂度为最坏时间复杂度，指算法计算量可能达到的最大值；算法的平均时间复杂度是指算法在所有可能下，按照输入实例以等概率出现时，算法计算量的加权平均值。</p><blockquote><p>空间复杂度</p></blockquote><pre><code class="hljs">    空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做$S(n)=O(f(n))$。</code></pre><p>空间复杂度比时间复杂度稍微容易一点。只需要理解了空间复杂度的意思即可。</p><p>首先，我们先官方一波。</p><p>有关于算法的存储空间需求，类似于算法的时间复杂度，我们采用渐进空间复杂度(Space Complexity)作为算法所需存储空间的量度。简称空间复杂度，它也是问题规模$n$的函数，记作:</p><p> $S(n) &#x3D; O(f(n))$</p><p>一般情况下，一个程序在机器上执行时，除了需要寄存本身所用的指令、常数、变量、和输入数据外，还需要一些对数据进行操作的辅助存储空间。其中，对于输入数据所占的具体存储量取决与问题本身，与算法无关。这样，只需要分析该算法在实现时所需要的辅助空间就可以了。</p><p>空间复杂度个人理解(如果不对，请大佬指出。)</p><p>(对于一个算法而言，所占用的空间一般分为3个。</p><ol><li><p>输入的数据空间</p></li><li><p>指令、常数所本身占用的空间(该空间是固定的。一般是按照需求来的。</p></li><li><p>辅助存储空间。(在执行某些计算时，所借助的临时存储空间。例如，在将两个数据交换时，如果对于一个整数而言，能够保证数据相加相减都不会超过整数的范围之外时，利用相加或者相减法会比借助临时存储空间的空间复杂度要低。</p></li></ol><p>而一般而言，空间复杂度指的是辅助存储空间的大小。如果借助辅助存储空间的大，则空间复杂度就大，反之，空间复杂度就少。所以，注意一下辅助空间的大小即可。)</p><blockquote><p>空间复杂度和时间复杂度的相爱相杀</p></blockquote><p>&emsp;空间复杂度和时间复杂度是评判算法优劣性的两大衡量点。要评判算法的好坏，时间复杂度和空间复杂度是离不开的，但是，对于一个算法而言，其时间复杂度和空间复杂度往往是互相影响的，当追求一个较好的时间复杂度时，往往需要大量的辅助空间作为缓存，而当追求一个较好的空间复杂度时，往往使得执行语句的次数会变多，从而影响时间复杂度。真的是相爱相杀呀。</p><p>（通常，鉴于现如今运算空间较为充足，人们往往以时间复杂度为重。）</p><blockquote><p>总结</p></blockquote><p>时间复杂度和空间复杂度是一个比较抽象的东西了，&#x3D;-&#x3D;因为需要一些数学知识。空间复杂度还好，只是这时间复杂度，emmmmm。有点难度。下面个人总结一下时间复杂度以及空间复杂度。然后再做一些习题巩固。</p><p>时间复杂度：时间复杂度是指执行算法所需要的计算工作量。可以用算法在执行过程中所需基本运算的执行次数来度量算法的工作量。</p><p>(时间复杂度取决于算法中基本运算执行的次数，与计算机本身无关。)</p><p>计算时间复杂度需要4步。</p><p>1.求出“基本语句”所需要的频数之和。</p><p>2.只保留最高项。</p><p>3.将最高项系数都化为1。(如果只留下了常数，则为时间复杂度为常数阶。)</p><p>4.带入公式。</p><p>空间复杂度：是对一个算法在运行过程中临时占用存储空间大小的量度。</p><p>一般而言，空间复杂度指的是辅助存储空间的大小。</p><blockquote><p>例题：</p></blockquote><p>例题1:设n是描述问题规模的非负整数，则下面程序段的时间复杂度为____________。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">x=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(x&lt; n/<span class="hljs-number">2</span> )<br>    x = <span class="hljs-number">2</span> *x;<br></code></pre></td></tr></table></figure><p>例题2：下面程序段的时间复杂度是_________。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k\leq n;k*=<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j\leq n;j++)<br>        count++;<br></code></pre></td></tr></table></figure><p>例题3:以下程序段中语句”x++”的语句频度为___________。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=i;j++) <br>        <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=j;k++) <br>x++；<br></code></pre></td></tr></table></figure><p>例题4:以下程序段语句中”m++;”的语句频度为________。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> m=<span class="hljs-number">0</span>,i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>*i;j++)<br>            m++;<br></code></pre></td></tr></table></figure><p>例题5：设一维数组中有n给数组元素，则读取第i个数组元素的平均复杂度为________。</p><blockquote><p>解答</p></blockquote><p>例题1:</p><p>设程序中基本语句“x&#x3D;2*x;”执行的次数为K，执行K次时: $x&#x3D;2^(k+1)$。由循环结束条件$x&lt;n&#x2F;2$可得。$2^(k+1)&lt;n&#x2F;2$。即$k&lt;\log_2 n -2,K&#x3D;\log_2 n +C$（C为常数），因此$T(n) &#x3D; O(\log_2 n )$。</p><p>例题2:</p><p>外循环:条件为$k\leq n$，增量为$k*&#x3D;2$；可以知道循环次数为$2^k\leq n$ 。即 $k\leq \log_2 n$。所以最外层的时间复杂度为 $O(\log_2 n)$。</p><p>内循环:条件为$j\leq n$，增量为j++;可以找到循环次数为n次，即内层循环的时间复杂度为$O(n)$。</p><p>则该程序的时间复杂度为:$T(n)&#x3D;O(\log_2 n )*O(n)&#x3D;O(n\log_2 n)$</p><p>例题3:</p><p>“x+;”的语句频度为: $\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^i \sum_{k&#x3D;1}^j1&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^i j&#x3D;\sum_{i&#x3D;1}^n \frac{i(i+1)}{2}&#x3D;\frac{1}{2}(\sum_{i&#x3D;1}^n i^2+\sum_{i&#x3D;1}^n i)&#x3D;\frac{n(n+1)(n+2)}{6} $</p><p>例4：</p><p>“m++”的语句频度为:</p><p>$\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^{2i} 1&#x3D;\sum_{i&#x3D;1}^n 2i&#x3D;2\sum_{i&#x3D;1}^n i&#x3D;n(n+1)  $</p><p>例题5:</p><p>因为读取第i个数组元素可以直接通过数组下标定位，与$n$无关，所以平均时间复杂度为$O(1)$。</p><p>参考资料：【1】<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/5930669?fromtitle=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&fromid=1894057&fr=aladdin">百度百科 - 时间复杂度</a></p><p>                  【2】<a href="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/9664257?fr=aladdin">百度百科 - 空间复杂度</a></p><p>                 【3】<a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.139.169d4de0CviPr5&id=589691975440&ns=1&abbucket=14">数据结构(C语言版)-严蔚敏</a></p><p>                  【4】<a href="https://www.cnblogs.com/wt869054461/p/9764834.html">时间复杂度和空间复杂度的简单讲解</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识算法</title>
    <link href="/2020/01/31/%E8%AE%A4%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2020/01/31/%E8%AE%A4%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我们为什么要学习算法？</p></blockquote><p>正所谓：数据结构 + 算法 &#x3D; 程序 。当我们了解了数据结构时，就必须要了解一下算法。因为数据结构和算法是分不开的。<strong>对于某一类型的数据结构，总会涉及到对数据的运算。而我们只有通过对所定义运算的研究，才能够清楚的理解数据结构的定义和作用。同样，也才能够将该数据类型的效果最大化。</strong></p><p>算法联系着数据在计算过程中的组织方式，为了让数据在计算过程中得到最安全，最快，最有效的方法，我们常常需要设计算法。</p><p><strong>学习算法，不仅能让自己思维能力更是一个台阶，也能在大数据和人工智能时代为自己打下坚实的基础，成为互联网行业的高端人才，而不是一直停留在低水平的体力编程层次。</strong></p><p>编程不只是简简单单的实现功能。对于其性能，安全，存储空间大小等等都会有较高的要求。假设你遇到下面这种情况，你会怎么选择？</p><p><img src="/img/docs/%E8%AE%A4%E8%AF%86%E7%AE%97%E6%B3%95/1.webp">  </p><p>应用程序没有响应  </p><p>如果是我，我将会结束进程，因为只有鬼才知道我需要等待多久。我相信，大部分人是没有这样的耐心的。这就是当处理数据时，数据量过大，程序一直在运算，需要耗费大量的时间在后台运算，导致了程序进程没有响应。或者就是内存泄漏和内存溢出等问题。而合适的算法通常就是解决这类问题。</p><blockquote><p>算法的定义以及特性</p></blockquote><p>**算法（Algorithm）：**为了解决某类问题而规定的一个有限长的操作序列。</p><p>一个算法必须要满足以下五种重要特性。</p><p><em><strong>（1）有穷性(Finiteness)：一个算法必须要要在执行有限次步骤后结束，且每一步都必须要在有限的有限的时间内完成。</strong></em></p><p>（有穷性确定了算法是能够正常运转的，也保证其算法是由意义的的。试想一下，一个算法没有终点，那还有意义吗？）</p><p><em><strong>（2）确定性(Definiteness)：对于每一种情况下所执行的操作，在其算法中都有确切的规定，不会产生二义性。</strong></em></p><p>（确定性能够使得算法的执行者或阅读者都能明白其含义及如何执行。程序不是一个人的程序，而是团队的程序。确定性能够帮助自己或者他人能够很清楚的了解到该算法是怎么样的。当你的代码只有你一个人看的懂时，那其实已经是“烂代码”了。）</p><p><em><strong>(3）可行性(Effectiveness)：算法中的所以操作都可以通过已经实现的基本操作运算执行有限次来实现。</strong></em></p><p>（可行性规范了算法的运算，当你想要用一些其本身都没有的运算法则去进行运算，这是不可能的。就好比，你想要一个只会加减乘除的计算器去实现电脑，手机，卫星控制这样的功能一样。)</p><p><em><strong>(4）输入(Input)：一个算法中有零个或多个输入。</strong></em></p><p>（输入是用来刻画运算对象的初始情况的。零输入是指算法本身内部定义了初始情况。）</p><p><em><strong>(5）输出(Output)：一个算法有一个或多个输出。</strong></em></p><p>（输出是算法进行信息加工后所得出的结果。没有输出的算法是没有任何意义的。你没有输出，就相当于你没有结果，那么你定义的这个算法又有什么意义呢？）</p><blockquote><p>评价算法优劣的基本标准</p></blockquote><p>对于一个算法而言，其主要的还是要在能够解决问题的前提上看算法的优劣性。</p><p><strong>一个算法的优劣性主要是从正确性，可读性，健壮性，高效性这四个方面来评价。</strong></p><p>（1）**正确性：**在合理的数据输入下，能够在有限的运行时间内得到正确的结果。</p><p>（2）**可读性：**一个优良的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。因为可读性强的算法有助于人们对于算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。</p><p>（3）**健壮性：**对不合理数据输入的反应能力和处理能力，也称为容错性。</p><p>（4）**高效性：**高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来衡量；而空间高效是指算法占用存储容量的合理，可以用空间复杂度来衡量。<strong>时间复杂度和空间复杂度是衡量算法的两个主要指标。</strong></p><p>（这里暂时不讨论时间复杂度和空间复杂度。）</p><blockquote><p>衡量算法效率的方法</p></blockquote><p>衡量算法效率主要有两类：事后统计法和事前分析估算法。</p><p><strong>事后统计算法：通过测试程序和测试数据对已经实现了的算法用计算机计时器的运行时间进行比较以及对所使用的内存空间大小进行比较。</strong></p><p>（缺点：一是必须要把算法转化为可执行的程序，二是时空开销的测试结构依赖于计算机的软硬件等环境因素。）</p><p><strong>事前分析估计法：在编制程序前，依靠统计方法对算法的时空开销进行估算。</strong></p><p>（不考虑计算机的软硬件环境因素，影响算法时间代价的最主要因素是问题规模。【问题规模是算法求解问题输入量的多少。是问题大小的本质表示。】）</p><blockquote><p>扩展资料 ： 算法的分类</p></blockquote><p>算法可大致分为基本算法、数据结构的算法、数论与代数算法、计算几何的算法、图论的算法、动态规划以及数值分析、加密算法、排序算法、检索算法、随机化算法、并行算法，厄米变形模型，随机森林算法。</p><p>算法可以宏泛的分为三类：</p><p>一，有限的，确定性算法 这类算法在有限的一段时间内终止。他们可能要花很长时间来执行指定的任务，但仍将在一定的时间内终止。这类算法得出的结果常取决于输入值。</p><p>二，有限的，非确定算法 这类算法在有限的时间内终止。然而，对于一个（或一些）给定的数值，算法的结果并不是唯一的或确定的。</p><p>三，无限的算法 是那些由于没有定义终止定义条件，或定义的条件无法由输入的数据满足而不终止运行的算法。通常，无限算法的产生是由于未能确定的定义终止条件。</p><blockquote><p>总结</p></blockquote><p>算法对与程序而言是及其重要的。同时也是研究数据结构的重要途经。优良的算法能够给数据处理带来高效性，安全性等等。而我们，虽然说有可能日后用不上，但是学习算法能够提升自己的思维，培养自己的算法式思维。</p><p>参考资料：<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025?fr=aladdin#3">百度百科-算法</a></p><p>                <a href="https://www.jianshu.com/p/4c7cb2cee7d5">为什么我们要学习算法</a></p><p>                <a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.139.169d4de0CviPr5&id=589691975440&ns=1&abbucket=14">数据结构(C语言版)-严蔚敏</a></p><p>（嘻嘻，我是在参考上面加上了自己的理解哦。如果有错误，请大佬指点。）</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识数据结构</title>
    <link href="/2020/01/31/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/01/31/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是什么?</p></blockquote><p>    <strong>数据结构是相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 ，是计算机的存储、组织数据的方式。</strong></p><p>       在早期中，计算机主要是科学家们被用来数值计算。但如今，随着时代的发展，计算机已经除了用于数值计算，更多的是使用在处理字符、表格、图像、视频，音乐等多种具有一定结构的数据。而对于错综复杂的数据，只有对数据进行理性化的分析，合理化的处理，才能对其有效的处理。而数据结构，就是对数据的一种合理化分析所的出的结论。<em><strong>合理的数据结构对于数据的分析，处理具有极大的帮助。</strong></em></p><blockquote><p><strong>基本概念与术语</strong></p></blockquote><p>    1.<strong>数据(Data) :</strong> 数据是指对客观事件进行记录并可以鉴别的符号，是对客观事物的性质、状态以及相互关系等进行记载的物理符号或这些物理符号的组合。它是可识别的、抽象的符号。</p><p>(***数据是客观的表现。是所有能够输入到计算机中并被计算机程序所处理的符号的总称。***例如一张成绩表，就是对成绩的一种客观表现，我们可以通过成绩表，清楚的了解到各科学生的成绩)</p><p>    2.**数据元素(Data Element):**数据元素是数据的基本单位，有时也被称作为结点或记录。在计算机中，通常作为一个整体进行考虑和处理。</p><p>（***数据元素是数据的基本单位，数据是由有众多的数据元素组成的。***例如成绩表是由各个学生的成绩所组成。单个学生的成绩就是数据元素，而成绩表就是数据。）</p><p>    3.**数据项(Data Item):**数据项是组成数据元素的，具有独立意义的，不可分割的最小单位。数据项通常用于表示实体的某种属性。</p><p>（**数据项是数据的最小单位，具有独立意义且不可分割性。通常是用于表示实体的某种属性。**例如，在成绩表中，学生们单个的成绩就是数据项，语文成绩，数学成绩，等等。这些成绩具有独立的意义，能够表示一名学生的某科的成绩属性。且具有不可分割性。）</p><p>    4.**数据对象(Data Object):**数据对象是性质相同的数据元素的集合。是数据的一个子集。</p><p>（**数据对象是性质相同的数据元素的集合。**例如，在一张成绩表中，具有学生的学号和姓名已经班级等信息，还包含学生的各项成绩以及各种平均成绩和排名。那么可以说成绩表中(数据)是由学生的基本信息（数据对象）和学生的成绩（数据对象）组成。因为数据对象是数据元素的集合，而数据元素是数据的基本单位，所以并不矛盾。）</p><p>    4种有关数据基本概念如图：</p><p><img src="/img/docs/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.webp"></p><p>数据的基本概念</p><blockquote><p>数据结构的两种层次</p></blockquote><p>        <strong>数据结构包括逻辑结构和存储结构两个层次。</strong></p><p><strong>逻辑结构：</strong></p><p>        数据的逻辑结构是从数据的逻辑关系上进行描述数据。它与数据的存储无关，是独立与计算机的。是将具体问题抽象出来的数学模型。</p><p>        逻辑结构拥有两个要素：<strong>数据元素</strong>和<strong>关系</strong>。</p><p>        数据元素是数据的基本单位，而关系是指数据元素之间的逻辑关系。根据数据元素之间关系的不同特性，通常可以分为四类基础结构。</p><p>        <strong>集合结构：<strong>集合结构是一种松散的结构。该结构使得数据</strong>除了“属于同一种集合”的关系</strong>外，无其它关系。</p><p><img src="/img/docs/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.webp">  </p><p>集合结构  </p><p>        <strong>线性结构：<strong>线性结构是一个有序数据元素的集合。该结构</strong>存在一对一的关系</strong>。</p><p><img src="/img/docs/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.webp">  </p><p>线性结构  </p><p>        <strong>树结构：<strong>树结构是一种将数据元素按分支关系组织起来的结构。该结构</strong>存在一对多的关系</strong>。</p><p><img src="/img/docs/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.webp">  </p><p>树结构</p><p>        **图结构：**图结构是一种比树更加复杂的结构，该结构的任意两个结点都有可能具有关联性。<strong>存在多对多的关系。</strong></p><p><img src="/img/docs/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.webp">  </p><p>图结构  </p><p>在四种基本结构中，可以分为线性结构和非线性结构。整体如下：</p><p><img src="/img/docs/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.webp">  </p><p>逻辑姐层次图  </p><p>        线性结构包含：线性表，数组，栈，队列，串，广义表。</p><p>        非线性结构包含：树，图，集合。（树有常见的二叉树，森林，B树，B-\B+树等等，图分为有向图和无向图）。</p><p><strong>存储结构：</strong></p><p>        数据对象在计算机中的存储表达成为数据的<strong>存储结构</strong>。对于计算机的任何数据，无论是什么形式，都是以二进制存储的。而在内存条是一维线性结构，数据的处理都是在内存条中进行的。所以，数据的存储结构可以分为<strong>顺序存储</strong>和<strong>链式存储</strong>。</p><p><strong>顺序存储</strong>：所有的数据元素依次存放在一片连续的内存空间中，通过相对位置来形成联系。是连续的存储方式。通常是以数组的形式进行表示。</p><p><strong>链式存储</strong>：所有的数据元素通过结点的附加空间的指针字段来形成联系。数据元素在内存中的数据通常是不连续的。是不连续的存储方式。通常是以链表的形式进行表示。</p><p>（数据结构是将具体问题抽象化后，寻找出其相对应的数据元素以及数据元素之间的关系。再对其考虑是使用顺序存储还是用链式存储。<strong>注意：逻辑结构中的关系与存储结构没有关系。线性结构既可以使用存储结构，也可以使用链式存储，非线性结构也是一样。</strong>）</p><blockquote><p>数据类型和抽象数据类型</p></blockquote><p>**数据类型（Data Type）：**数据类型是高级程序设计语言中的一个基本概念。是一个值的集合和定义在这个值集上面的一组操作的总称。</p><p>（数据类型一般在程序设计语言中都有着其基本的数据类型，再由这些基本数据类型构成复杂的数据类型。）</p><p>**抽象数据类型（Abstract Data Type）:**一般是值用户定义的，表示应用问题的数学模型。具体包括三部分：数据对象，数据对象上关系的集合以及数据对象的基本操作的集合。</p><p>抽象数据类型的定义格式如下：</p><p><strong>ADT 抽象数据类型名{</strong></p><p>    <strong>数据对象:(数据对象的定义)</strong></p><p>    <strong>数据关系:(数据关系的定义)</strong></p><p>    <strong>基本操作:(基本操作的定义)</strong></p><p><strong>}ADT 抽象数据类型名</strong></p><p><strong>抽象数据类型的概念与面向对象的方法的思想是一致的。</strong></p><blockquote><p>总结</p></blockquote><p>数据结构是一门综合性的学科。其具有一定的抽象性，是将现实生活中各种各样的数据进行抽象化，使用不同的数据结构用来对现实世界模拟。</p><p>反正数据结构肯定是很重要的就对了。毕竟：数据结构+算法&#x3D;程序 嘛。</p><p>（嘻嘻，本次记录借鉴了严蔚敏的数据结构C语言版，是由人民邮电出版社出版的。同时也有部分参考了百度百科上面的j。数据结构与算法对于IT专业来说，考研应该是必须的。这一次记录让我对与数据结构再一次学习了一下。也对自己的数据结构的知识有了一定的认识。感觉自己又学到许多。）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA环境安装(1.8示例)</title>
    <link href="/2020/01/30/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <url>/2020/01/30/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Java所需要了解的一些事</p></blockquote><p>首先，对于JAVA来说，JAVA环境配置需要了解一下几个内容。</p><p>1.JDK(Java Development Kit) 是 Java 语言的软件开发工具包(<a href="https://baike.baidu.com/item/SDK">SDK</a>)。即，需要开发JAVA软件的话，JDK是必须要的。</p><p>    JDK中分为SE,EE,ME三个版本。</p><p>    SE(JavaSE，standard edition ：标准版，是我们通常使用的一个版本，从JDK 5.0开始，改名为Java SE。</p><p>    EE(JavaEE，enterprise edition）：企业版，使用这种JDK开发J2EE应用程序，从JDK 5.0开始，改名为Java EE。从2018年2月26日开始，J2EE改名为Jakarta EE。</p><p>    ME(J2ME，micro edition）：主要用于移动设备、嵌入式设备上的java应用程序，从JDK 5.0开始，改名为Java ME。</p><p>2.JRE(Java Runtime Environment）是 Java 语言的运行环境。 其包括Java虚拟机（JVM），Java核心库和支持文件。即，如果要运行JAVA程序的话，JRE是必须的。</p><p>3.JVM(Java Virtual Machine）：是Java<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a>，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><p>（目前Java的最高版本是13版本，但是不推荐安装其最高版本，因为市面上的Java版本大部分是1.7，1.8版本，如果Java版本安装过高，会出现不兼容现象。）</p><blockquote><p>Java环境安装</p></blockquote><p>    首先，访问官网，下载安装包。</p><p>    官网链接：  <em><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html">Java SE下载地址</a></em></p><p>                       <a href="https://www.oracle.com/cn/java/technologies/java-ee-glance.html">Java EE下载地址</a></p><p>                        <a href="https://www.oracle.com/java/technologies/javameoverview.html">Java ME下载地址</a></p><p>（其实JAVA SE下载地址中已经包含了其它的下载地址。另外，Java SE已经满足日常学习。没有必要要求，无需安装Java EE。Java是由Sun公司开发的，后来被甲骨文公司所购买。）</p><p>  <em><strong>访问官网下载</strong></em>         </p><p> 1.访问官网，下载相对应的 Java 版本安装包。</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1.webp">  </p><p>访问官网</p><p>2.选择自己相对应的系统版本安装包</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/2.webp">  </p><p>下载相对应的安装包  </p><p><em><strong>Windows版本安装</strong></em></p><p>    1.访问官网下载相对应安装包。</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/3.webp">  </p><p>3.用管理员权限打开下载好的软件。</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/4.webp">  </p><p>打开的界面  </p><p>下一步</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/5.webp">  </p><p>选择JDK的位置  </p><p>点击下一步，操作一部分会弹出JRE的安装程序。安装的进度条也会卡住。请注意。</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/6.webp">  </p><p>JRE安装  </p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/7.webp">  </p><p>安装成功！  </p><p>你以为这样就安装成功了吗？不，我们可能还需要配置一些环境变量。</p><p>4.配置环境变量</p><p>打开环境变量设置有多种方法。</p><p>    方法一：通过我的电脑-&gt;<strong>双击此电脑</strong>-&gt;计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量。</p><p>    方法二：Windows键+R打开运行（或者在开始里面找到运行）-&gt;输入 <strong>sysdm.cpl</strong> 之后确定 -&gt;高级-&gt;环境变量。</p><p>这里使用方法一：</p><p>打开我的电脑<br><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/8.webp">  </p><p>点击计算机<br><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/9.webp">  </p><p>点击属性<br><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/10.webp"> </p><p>点击高级系统设置<br><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/11.webp"> </p><p>点击环境变量<br><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/12.webp">  </p><p>Java配置环境变量需要两个设置，一个JAVA_HOME，一个是CLASSPATH.</p><p>JAVA_HOME:用于指示Java开发环境。告诉操作系统在哪个目录下可以寻找到相对应的Java开发软件，同时也是部分IDE所需要的。</p><p>CLASSPATH:用于告诉Java执行环境，在哪些目录下可以找到所要执行的Java程序所需要的类或者包。 </p><p>下面，就配置Java的环境变量</p><p>1.在系统变量中，新键环境变量</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/13.webp">  </p><p>新建环境变量</p><p>2.在变量名中填写 <strong>JAVA_HOME</strong> ，在变量值中填写之前所安装的JDK的位置。确定即可。我之前安装设置在D盘下的JAVA目录下的JDK目录。</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/14.webp">  </p><p>配置JAVA_HOME</p><p>3.然后在系统变量中找到变量为Path,选中之后点击编辑。如果不是长条，就按下图操作。</p><p>    （1）.新建一个，然后在框中输入一个小点（英文） .</p><p>    （2）.继续新建一个，然后在框中输入 %JAVA_HOME%\bin</p><p>如图所示</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/15.webp">  </p><p>配置Path</p><p>如果不是上图类型，就在变量值框中输入以下语句: <strong>;.;%JAVA_HOME%\bin</strong></p><p>4.接着继续新建一个系统变量，在变量名中填写 <strong>CLASSPATH</strong> ,在变量值中填写</p><p> <strong>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar</strong></p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/16.webp">  </p><p>配置CLASSPATH  </p><p>(注意：JAVA版本在1.5以上，不配置CLASSPATH也可以正常编译和运行JAVA)</p><p>5，确认保存退出即可完成配置。</p><p>6.检验是否安装成功:</p><p>        1.首先 Windows键+R，弹出运行，（也可以直接在开始中搜索）</p><p>        2.输入cmd，弹出cmd控制台。</p><p>（上述两个操作可以在开始直接搜索cmd运行控制台）.    </p><p>       3.输入 javac，看是否出现下图</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/17.webp">  </p><p>成功示意图  </p><p>    4.输入 java，看是否出现下图</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/18.webp">  </p><p>成功示意图  </p><p>（javac是java的编译器，java是java的运行。）</p><p>Windows安装Java完成！</p><p>    <em><strong>Linux 版本安装</strong></em></p><p><em><strong>Linux版本的Java可以直接搜索安装。这个就不用多说了，下面是到官方下载相应的包，解压后安装过程。</strong></em></p><p>1.访问官网下载相对应的包</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/19.webp">  </p><p>2.创建目录</p><p>在usr目录下创建Java目录。</p><p>在终端中输入指令</p><p><strong>sudo mkdir &#x2F;usr&#x2F;local&#x2F;Java</strong></p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/20.webp">  </p><p>创建文件夹  </p><p>3.将Java解压到目录</p><p>1.先切换到包含Java安装包的文件夹中</p><p>2.解压文件到&#x2F;usr&#x2F;local&#x2F;Java中</p><p><strong>sudo tar -zxvf 你Java安装包的名字 -C &#x2F;usr&#x2F;local&#x2F;Java</strong></p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/21.webp">  </p><p>解压安装包</p><p>3.配置Java环境变量   </p><p>（先移动到&#x2F;usr&#x2F;local&#x2F;Java目录下，查看文件名）</p><p>    (2).然后将光标移动到最后的位置，按下按钮 i 键，进入编辑模式</p><p>    (3).添加如下语句</p><p>        <strong>set java environment</strong></p><p>        <strong>JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Java&#x2F;<del>jdk1.8.0_241</del></strong>   </p><p>        <strong>JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Java&#x2F;<del>jdk1.8.0_241</del>&#x2F;jre</strong>   </p><p>        <strong>CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</strong></p><p>        <strong>PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</strong></p><p>        <strong>export JAVA_HOME JRE_HOME CLASS_PATH PATH</strong></p><p>   (注意：删除线包括的部分（jdk1.8.0_241）是由java包解压后的文件名所决定。也就是&#x2F;usr&#x2F;local&#x2F;Java目录下的文件夹。如果Java目录不是安装在&#x2F;usr&#x2F;local&#x2F;Java目录下，请自行更改)</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/22.webp">  </p><p>4.在编辑模式下，按下<strong>Esc</strong>键退出编辑模式，然后在<strong>Shift+:</strong>，进入命令模式，输入<strong>wq</strong>后保存退出。（不保存退出是<strong>q!</strong>）</p><p>5.对修改的配置进行设置生效</p><p>在命令行中输入</p><p><strong>sudo -s</strong></p><p><strong>source &#x2F;etc&#x2F;profile</strong></p><p>6.测试Java是否安装成功</p><p>(1.测试javac)</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/23.webp">  </p><p>javac成功示意图</p><p>（2.测试java）</p><p><img src="/img/docs/JAVA%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/24.webp">  </p><p>java成功示意图  </p><p>Linux Java环境安装完成。</p><blockquote><p>总结</p></blockquote><p>Java安装较难的地方是难在配置环境变量上面，需要了解环境变量是怎么回事以及如何配置。其它的都还好。</p><p>嘻嘻，写的不好还请大神指点。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS Code配置</title>
    <link href="/2020/01/29/Vs%20Code%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/01/29/Vs%20Code%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>VS Code</p></blockquote><p>       在学习的过程中，我一直在寻找一种编辑器能够方便的编写代码，因为自己觉得IDE(集成开发环境)有时候编写一个小小的程序有点小题大做。所以自己及其需要一种能够快速编写代码的编辑器。至此，自己寻找到了VS Code，并为其深深所折服。</p><p>    VS Code是微软在2015年4月30日Build 开发者大会上正式宣布的一款编写现代 Web 和云应用的跨平台源代码编辑器。其特别适合极简主义。而且比较美观。</p><p>    在此附上VS Code的官网链接:<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>        （注意: VS Code分为User版和System版本，主要是权限不同，User版本权限较低，System版本权限高些，为了不必要的麻烦，推荐使用System版本。【User版本我在逛CSDN时看到好像有人说一些快捷键，文件跳转，以及代码报错检验是无法使用的。我也没有尝试，不能确定其是否属实。反正System版本香一些就够了。】）</p><blockquote><p>(￣▽￣)”下载VS Code</p></blockquote><p>1.访问官网</p><p><img src="/img/docs/VsCode%E9%85%8D%E7%BD%AE/1.webp">  </p><p>VS Code官网图  </p><p>2.点击导航栏上的下载按钮</p><p><img src="/img/docs/VsCode%E9%85%8D%E7%BD%AE/2.webp">  </p><p>点击导航栏上面的下载按钮</p><p>3.选择自己所需要的版本</p><p><img src="/img/docs/VsCode%E9%85%8D%E7%BD%AE/3.webp">  </p><p>选择自己的版本下载  </p><p>4.点击下载即可。</p><blockquote><p>安装教程</p></blockquote><p>安装过于简单，在此就算了。根据自己喜爱安装。</p><blockquote><p>配置教程</p></blockquote><p>一：配置中文</p><p><img src="/img/docs/VsCode%E9%85%8D%E7%BD%AE/4.webp">  </p><p>配置中文  </p><p>安装成功重启即可。</p><p>二：配置JAVA环境</p><p><img src="/img/docs/VsCode%E9%85%8D%E7%BD%AE/5.webp">  </p><p>配置JAVA环境</p><p>（注意：需要JDK【JAVA语言开发工具包】，我是1.8版本。）</p><p>三：配置Python环境</p><p><img src="/img/docs/VsCode%E9%85%8D%E7%BD%AE/6.webp">  </p><p>配置Python环境  </p><p>（注意：需要Python环境。VS Code只是编辑器）</p><p>四，其它配置</p><p>1: Material Icon Theme漂亮的图标库</p><p>2：Bracket Pair Colorizer：自动匹配花括号的位置（确定花括号的位置）</p><p>3：Code Runner 运行代码</p><p>4:  background 设置背景图</p><blockquote><p>卸载 VS Code</p></blockquote><p>因为VS Code卸载不干净。卸载之后再次重装会出问题，所以在此也记录一下。</p><p>1.先卸载VS Code</p><p>2.删除用户以及缓存信息：</p><p>      (1).先Windows键+R 弹出运行。(也可以在开始中搜索)</p><p>      (2).在运行中输入 <strong>%appdata%</strong></p><p>      (3).找到 <strong>Code</strong> 文件夹,将其删除。（如果有<strong>Visual Studio Code</strong>也一并删除掉）</p><p>3.删除插件包</p><p>     （1）.先Windows键+R 弹出运行 。（也可以在开始中搜索）</p><p>     （2）.在运行中输入 <strong>%userprofile%</strong></p><p>     （3）.找到 <strong>.vscode</strong> 文件夹，将其删除。</p><p>嘻嘻，写的不好还请大神指点。</p>]]></content>
    
    
    <categories>
      
      <category>集成开发环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello,World</title>
    <link href="/2020/01/29/%E4%BD%A0%E5%A5%BD,%E4%B8%96%E7%95%8C/"/>
    <url>/2020/01/29/%E4%BD%A0%E5%A5%BD,%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>初次见面</p></blockquote><p>        大家好，我是一名选择了程序员之路的菜鸡学生，在2018年考完之后，在多次考虑之后，选择了物联网专业作为自己的未来之路。在该专业中，大一第一学期，我学到了C语言，大一第二学期，我接触到了C++，同时也接触到了Python，我现在是大二了，接触了JAVA和数据结构。</p><p>        在学习大致上的学了许多语言后，才了解到，其实语言并不需要学习很多，算法才是程序的灵魂，纵使自己学了许许多多的语言，自己编写代码的能力还是没有提上来。自己还有很长的路要走。在多次考虑下，我决定将JAVA作为自己的主要语言，将C++作为次要(其实我想选择GO，但是那个语言的语法可能不是太适合我[因为自己习惯了C和C++这种语法结构。]，有点犹豫)。因为语言有点多，学习了这种，忘记了那种，再加上自己经常格式化系统，自己急需要改变自己不记笔记的坏习惯，在众多的论坛里面，我选择了简书作为自己记录的第一路。</p><p>    愿自己坚持，加油，努力，不要放弃。自己选的路，死也要走完!</p><blockquote><p>再次见面</p></blockquote><p>&emsp;&emsp;在今天，我使用了Hexo+Github Pages搭建了这一份自己的静态博客,原本之前是在<a href="https://www.jianshu.com/u/b8e4d58db7d4">简书-筏执</a>上面写博客的，但是后来总想着自己搭建一个博客系统,自己慢慢写,虽然,这样看的人更少了，但是,博客有时候不是写给别人看的，更多的是写给自己，给自己这个粗心大意的人提个醒。</p><p>&emsp;&emsp;现如今我以及大三了，再过一年便要出入社会了，回忆起自己在大学的时光里，自己的时间匆匆流过,以前想的大学里面做的事情，现如今一件事情也没有完成，反而觉得越来越远了。</p><p>&emsp;&emsp;自己的事情,终究要自己去解决，虽然有时候放弃是最好的选择，但是,当在劫难逃，索性不逃！</p><blockquote><p>再再次见面</p></blockquote><p>&emsp;&emsp;没想到再再次见面已是五年，在这五年里，我自己也工作3年了快，在2020年那个时候，我还觉得我自己会是去做程序员，开发程序，在大三大四那两年里发生了太多的事情，无论是对我的恋爱观还是我的事业观都有很大的冲击，导致我自己最后也没有去选择做程序员。</p><p>&emsp;&emsp;不过现在也挺好，还是那句话，“不要把爱好变成工作，这样你就会失去一个爱好。”时至今日，在适应了工作的环境后，我也还是继续捡起了github和自己的博客，继续撰写你的故事吧，少年。【不对，应该叫中年了，哈哈，人老了】</p>]]></content>
    
    
    <categories>
      
      <category>Me</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
